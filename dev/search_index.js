var documenterSearchIndex = {"docs":
[{"location":"constraint_api.html","page":"Constraints","title":"Constraints","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"constraint_api.html#constraint_api","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraint_api.html","page":"Constraints","title":"Constraints","text":"This page provides details about the various types in TrajectoryOptimization.jl for working with constraints, as well as the methods defined on those types.","category":"page"},{"location":"constraint_api.html#Constraint-List","page":"Constraints","title":"Constraint List","text":"","category":"section"},{"location":"constraint_api.html","page":"Constraints","title":"Constraints","text":"A ConstraintList is used to define a trajectory optimization Problem and only holds basic information about the constraints included in the problem. ","category":"page"},{"location":"constraint_api.html","page":"Constraints","title":"Constraints","text":"ConstraintList\nadd_constraint!\nnum_constraints\nconstraintindices\nfunctionsignature\ndiffmethod\ngen_jacobian","category":"page"},{"location":"constraint_api.html#TrajectoryOptimization.ConstraintList","page":"Constraints","title":"TrajectoryOptimization.ConstraintList","text":"ConstraintList\n\nStores the set of constraints included in a trajectory optimization problem. Includes a list of both the constraint types AbstractConstraint as well as the knot points at which the constraint is applied. Each constraint is assumed to apply to a contiguous set of knot points.\n\nA ConstraintList supports iteration and indexing over the AbstractConstraints, and iteration of both the constraints and the indices of the knot points at which they apply via zip(cons::ConstraintList).\n\nConstraints are added via the add_constraint! method, which verifies that the constraint dimension is consistent with the state and control dimensions at the knot points at which  they are applied. \n\nThe total number of constraints at each knot point can be queried using the num_constraints method.\n\nConstructors\n\nConstraintList(nx, nu)\nConstraintList(n, m, N)\nConstraintList(models)\n\nWhere nx and nu are N-dimensional vectors that specify the state and control dimension  at each knot point. If these are the same for the entire trajectory, the user can use the  2nd constructor. Alternatively, they can be constructed automatically from models, a  vector of DiscreteDynamics models.\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.add_constraint!","page":"Constraints","title":"TrajectoryOptimization.add_constraint!","text":"add_constraint!(cons::ConstraintList, con::AbstractConstraint, inds::UnitRange, [idx, sig, diffmethod])\n\nAdd constraint con to ConstraintList cons for knot points given by inds.\n\nUse idx to determine the location of the constraint in the constraint list. idx=-1 (default) adds the constraint at the end of the list.\n\nThe FunctionSignature and DiffMethod used to evaluate the constraint can be specified by the sig and diffmethod keyword arguments, respectively.\n\nExample\n\nHere is an example of adding a goal and control limit constraint for a cartpole swing-up.\n\n# Dimensions of our problem\nn,m,N = 4,1,51    # 51 knot points\n\n# Create our list of constraints\ncons = ConstraintList(n,m,N)\n\n# Create the goal constraint\nxf = [0,π,0,0]\ngoalcon = GoalConstraint(xf)\nadd_constraint!(cons, goalcon, N)  # add to the last time step\n\n# Create control limits\nubnd = 3\nbnd = BoundConstraint(n,m, u_min=-ubnd, u_max=ubnd, idx=1)  # make it the first constraint\nadd_constraint!(cons, bnd, 1:N-1)  # add to all but the last time step\n\n# Indexing\ncons[1] === bnd                            # (true)\ncons[2] === goal                           # (true)\nallcons = [con for con in cons]\ncons_and_inds = [(con,ind) in zip(cons)]\ncons_and_inds[1] == (bnd,1:n-1)            # (true)\n\n\n\n\n\n","category":"function"},{"location":"constraint_api.html#TrajectoryOptimization.num_constraints","page":"Constraints","title":"TrajectoryOptimization.num_constraints","text":"num_constraints(::ConstraintList)\nnum_constraints(::Problem)\n\nReturn a vector of length N constaining the total number of constraint values at each knot point.\n\n\n\n\n\n","category":"function"},{"location":"constraint_api.html#TrajectoryOptimization.constraintindices","page":"Constraints","title":"TrajectoryOptimization.constraintindices","text":"constraintindices(::ConstraintList, i)\n\nGet the knot point indices at which the ith constraint is applied.\n\n\n\n\n\n","category":"function"},{"location":"constraint_api.html#TrajectoryOptimization.functionsignature","page":"Constraints","title":"TrajectoryOptimization.functionsignature","text":"functionsignature(::ConstraintList, i)\n\nGet the FunctionSignature used to evaluate the ith constraint in the constraint list.\n\n\n\n\n\n","category":"function"},{"location":"constraint_api.html#TrajectoryOptimization.diffmethod","page":"Constraints","title":"TrajectoryOptimization.diffmethod","text":"diffmethod(::ConstraintList, i)\n\nGet the DiffMethod used to evaluate the Jacobian for ith constraint in the constraint  list.\n\n\n\n\n\n","category":"function"},{"location":"constraint_api.html#TrajectoryOptimization.gen_jacobian","page":"Constraints","title":"TrajectoryOptimization.gen_jacobian","text":"gen_jacobian(con)\n\nGenerate a Jacobian of the correct size for constraint con.\n\n\n\n\n\n","category":"function"},{"location":"constraint_api.html#Implemented-Constraints","page":"Constraints","title":"Implemented Constraints","text":"","category":"section"},{"location":"constraint_api.html","page":"Constraints","title":"Constraints","text":"The following is a list of the constraints currently implemented in TrajectoryOptimization.jl. Please refer to the docstrings for the individual constraints on details on their constructors, since each constraint is unique, in general.","category":"page"},{"location":"constraint_api.html","page":"Constraints","title":"Constraints","text":"List of currently implemented constraints","category":"page"},{"location":"constraint_api.html","page":"Constraints","title":"Constraints","text":"GoalConstraint\nBoundConstraint\nLinearConstraint\nCircleConstraint\nCollisionConstraint\nSphereConstraint\nNormConstraint\nIndexedConstraint","category":"page"},{"location":"constraint_api.html","page":"Constraints","title":"Constraints","text":"GoalConstraint\nBoundConstraint\nLinearConstraint\nCircleConstraint\nSphereConstraint\nCollisionConstraint\nNormConstraint\nIndexedConstraint","category":"page"},{"location":"constraint_api.html#TrajectoryOptimization.GoalConstraint","page":"Constraints","title":"TrajectoryOptimization.GoalConstraint","text":"GoalConstraint{P,T}\n\nConstraint of the form x_g = a, where x_g can be only part of the state vector.\n\nConstructors:\n\nGoalConstraint(xf::AbstractVector)\nGoalConstraint(xf::AbstractVector, inds)\n\nwhere xf is an n-dimensional goal state. If inds is provided, only xf[inds] will be used.\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.BoundConstraint","page":"Constraints","title":"TrajectoryOptimization.BoundConstraint","text":"BoundConstraint{P,NM,T}\n\nLinear bound constraint on states and controls\n\nConstructors\n\nBoundConstraint(n, m; x_min, x_max, u_min, u_max)\n\nAny of the bounds can be ±∞. The bound can also be specifed as a single scalar, which applies the bound to all state/controls.\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.LinearConstraint","page":"Constraints","title":"TrajectoryOptimization.LinearConstraint","text":"LinearConstraint{S,P,W,T}\n\nLinear constraint of the form Ay - b leq= 0 where y may be either the state or controls (but not a combination of both).\n\nConstructor: ```julia\n\nLinearConstraint{S,W}(n,m,A,b) ``whereW <: Union{State,Control}`.\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.CircleConstraint","page":"Constraints","title":"TrajectoryOptimization.CircleConstraint","text":"CircleConstraint{P,T}\n\nConstraint of the form (x - x_c)^2 + (y - y_c)^2 geq r^2 where x, y are given by x[xi],x[yi], (x_cy_c) is the center of the circle, and r is the radius.\n\nConstructor:\n\nCircleConstraint(n, xc::SVector{P}, yc::SVector{P}, radius::SVector{P}, xi=1, yi=2)\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.SphereConstraint","page":"Constraints","title":"TrajectoryOptimization.SphereConstraint","text":"SphereConstraint{P,T}\n\nConstraint of the form (x - x_c)^2 + (y - y_c)^2 + (z - z_c)^2 geq r^2 where x, y, z are given by x[xi],x[yi],x[zi], (x_cy_cz_c) is the center of the sphere, and r is the radius.\n\nConstructor:\n\nSphereConstraint(n, xc::SVector{P}, yc::SVector{P}, zc::SVector{P},\n\tradius::SVector{P}, xi=1, yi=2, zi=3)\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.CollisionConstraint","page":"Constraints","title":"TrajectoryOptimization.CollisionConstraint","text":"CollisionConstraint\n\nEnforces a pairwise non self-collision constraint on the state, such that     norm(x[x1] - x[x2]).^2 ≥ r^2,     where x1 and x2 are the indices of the positions of the respective bodies and r     is the collision radius.\n\nConstructor\n\nCollisionConstraint(n::Int, x1::AbstractVector{Int}, x2::AbstractVector{Int}, r::Real)\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.NormConstraint","page":"Constraints","title":"TrajectoryOptimization.NormConstraint","text":"NormConstraint{S,D,T}\n\nConstraint of the form y_2 leq a where y is made up of elements from the state and/or control vectors. The can be equality constraint, e.g. y^T y - a^2 = 0, an inequality constraint, where y^T y - a^2 \\leq 0, or a second-order constraint.\n\nConstructor:\n\nNormConstraint(n, m, a, sense, [inds])\n\nwhere n is the number of states,     m is the number of controls,     a is the constant on the right-hand side of the equation,     sense is Inequality(), Equality(), or SecondOrderCone(), and     inds can be a UnitRange, AbstractVector{Int}, or either :state or :control\n\nExamples:\n\nNormConstraint(3, 2, 4, Equality(), :control)\n\ncreates a constraint equivalent to u^2 = 160 for a problem with 2 controls.\n\nNormConstraint(3, 2, 3, Inequality(), :state)\n\ncreates a constraint equivalent to x^2 leq 9 for a problem with 3 states.\n\nNormConstraint(3, 2, 5, SecondOrderCone(), :control)\n\ncreates a constraint equivalent to  x_2 leq 5.\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.IndexedConstraint","page":"Constraints","title":"TrajectoryOptimization.IndexedConstraint","text":"IndexedConstraint{C,N,M}\n\nCompute a constraint on an arbitrary portion of either the state or control, or both. Useful for dynamics augmentation. e.g. you are controlling two models, and have individual constraints on each. You can define constraints as if they applied to the individual model, and then wrap it in an IndexedConstraint to apply it to the appropriate portion of the concatenated state. Assumes the indexed state or control portion is contiguous.\n\nType params:\n\nS - Inequality or Equality\nW - ConstraintType\nP - Constraint length\nN,M - original state and control dimensions\nNM - N+M\nBx - location of the first element in the state index\nBu - location of the first element in the control index\nC - type of original constraint\n\nConstructors:\n\nIndexedConstraint(n, m, con)\nIndexedConstraint(n, m, con, ix::UnitRange, iu::UnitRange)\n\nwhere the arguments n and m are the state and control dimensions of the new dynamics. ix and iu are the indices into the state and control vectors. If left out, they are assumed to start at the beginning of the vector.\n\nNOTE: Only part of this functionality has been tested. Use with caution!\n\n\n\n\n\n","category":"type"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"rotations.html#Optimizing-Rotations","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"","category":"section"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"Optimization over the space of rotations is non-trivial due to the group structure  of 3D rotations. TrajectoryOptimization.jl provides methods for accounting for this group structure, both in the constraints and in the objective. We make the assumption that 3D rotation only show up in the state vector, and never in the control vector. TrajectoryOptimization.jl relies on the dynamics model to determine if the state vector contains rotations. See the  RobotDynamics.jl documentation for more details on defining models with rotations. From here, we assume that we are dealing with a model that inherits from RobotDynamics.LieGroupModel.","category":"page"},{"location":"rotations.html#Cost-Functions-(experimental)","page":"Optimizing Rotations","title":"Cost Functions (experimental)","text":"","category":"section"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"While normal quadratic cost functions can work with rotations (e.g. q_k^T Q q_k, where q_k is a quaternion, MRP, or RP), this distance metric isn't well-defined.  Since we often want to penalize the distance from a reference rotation  (such as a nominal or goal state), TrajectoryOptimization.jl provides a couple different methods for penalizing distance from a reference rotation. However, we've  discovered that the quaternion geodesic distance: ","category":"page"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"min 1 pm q_d^T q_k","category":"page"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"where q_d is the desired, or reference, quaternion, works the best. We've also  found that, while technically incorrect, a naive quadratic penalty can work quite well, especially when the difference between the rotations isn't significant. ","category":"page"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"The following cost functions are provided. Note that these methods should still be  considered experimental, and the interface made change in the future. If you encounter any issues using these functions, please submit an issue.","category":"page"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"DiagonalQuatCost\nQuatLQRCost\nErrorQuadratic","category":"page"},{"location":"rotations.html#TrajectoryOptimization.DiagonalQuatCost","page":"Optimizing Rotations","title":"TrajectoryOptimization.DiagonalQuatCost","text":"DiagonalQuatCost\n\nQuadratic cost function for states that includes a 3D rotation, that penalizes deviations      from a provided 3D rotation, represented as a Unit Quaternion.\n\nThe cost function penalizes geodesic distance between unit quaternions:\n\nfrac12 big( x^T Q x + u^T R u big) + q^T x + r^T u + c + w min 1 pm p_f^T p\n\nwhere p is the quaternion extracted from x (i.e. p = x[q_ind]), and p_f  is the reference quaternion. Q and R are assumed to be diagonal.\n\nWe've found this perform better than penalizing a quadratic on the quaternion error  state (ErrorQuadratic). This cost should still be considered experimental.\n\nConstructors\n\nDiagonalQuatCost(Q::Diagonal, R::Diagonal, q, r, c, w, q_ref, q_ind; terminal)\nDiagonalQuatCost(Q::Diagonal, R::Diagonal; q, r, c, w, q_ref, q_ind, terminal)\n\nwhere q_ref is the reference quaternion (provided as a SVector{4}), and      q_ind::SVector{4,Int} provides the indices of the quaternion in the state vector      (default = SA[4,5,6,7]). Note that Q and q are the size of the full state,      so Q.diag[q_ind] and q[qind] should typically be zero.\n\n\n\n\n\n","category":"type"},{"location":"rotations.html#TrajectoryOptimization.QuatLQRCost","page":"Optimizing Rotations","title":"TrajectoryOptimization.QuatLQRCost","text":"QuatLQRCost(Q, R, xf, [uf; w, quat_ind])\n\nDefines a cost function of the form:\n\nfrac12 big( (x - x_f)^T Q (x - x_f) + (u - u_f)^T R (u - u_f) big) + w min 1 pm q_f^T q\n\nwhere Q and R are diagonal, x_f is the goal state,  u_f is the reference control, and q_f, q are the quaternions, extracted from x using quat_ind, i.e. q = x[quat_ind].\n\nThe last term is the geodesic distance between quaternions. It's typically recommended that  Q.diag[quad_ind] == zeros(4).\n\nThis is just a convenience constructor for DiagonalQuatCost.\n\nExample\n\nFor a standard rigid body state vector x = [p; q; v; ω], where q is a unit quaternion, we could define a cost function that penalizes the distance to the goal state xf.  We can create this cost function as follows:\n\nQ = Diagonal(SVector(RBState(fill(0.1,3), zeros(4), fill(0.1,3), fill(0.1,3))))\nR = Diagonal(@SVector fill(0.01, 6))\nxf = RBState([1,2,3], rand(UnitQuaternion), zeros(3), zeros(3))\nQuatLQRCost(Q,R,xf)\n\nWe can add a reference control and change the weight on the rotation error with the optional arguments:\n\nQuatLQRCost(Q,R,xf,uf, w=10.0)\n\nwhich is equivalent to\n\nQuatLQRCost(Q,R,xf,uf, w=10.0, quat_inds=4:7)\n\n\n\n\n\n","category":"function"},{"location":"rotations.html#TrajectoryOptimization.ErrorQuadratic","page":"Optimizing Rotations","title":"TrajectoryOptimization.ErrorQuadratic","text":"ErrorQuadratic{Rot,N,M}\n\nCost function of the form:\n\nfrac12 (x_k ominus x_d)^T Q_k (x_k ominus x_d)\n\nwhere x_k ominus x_d is the error state, computed using  RobotDynamics.state_diff.  This cost function isn't recommended: we've found that DiagonalQuatCost usually     peforms better and is much more computationally efficient.\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#constraint_section","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"","category":"section"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"Pages = [\"constraints.md\"]","category":"page"},{"location":"constraints.html#Creating-Constraint-Sets","page":"3. Creating Constraints","title":"Creating Constraint Sets","text":"","category":"section"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"The easiest way to set up the constraints for your problem is through the ConstraintList. This structure simply holds a vector of all the constraints in the trajectory optimization problem. The easiest way to start is to create an empty ConstraintList:","category":"page"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"cons = ConstraintList(n,m,N)","category":"page"},{"location":"constraints.html#Adding-Constraints","page":"3. Creating Constraints","title":"Adding Constraints","text":"","category":"section"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"You can add any constraint (the list of currently implemented constraints is given in the following section) to the constraint set using the add_constraint! method. For example, if we want to add control limits and an final goal constraint to our problem, we do this by creating a ConstraintList and subsequently adding the constraints:","category":"page"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"# Dimensions of our problem\nn,m,N = 4,1,51    # 51 knot points\n\n# Create our list of constraints\ncons = ConstraintList(n,m,N)\n\n# Create the goal constraint\nxf = [0,π,0,0]\ngoalcon = GoalConstraint(xf)\nadd_constraint!(cons, goalcon, N)  # add to the last time step\n\n# Create control limits\nubnd = 3\nbnd = BoundConstraint(n,m, u_min=-ubnd, u_max=ubnd)\nadd_constraint!(cons, bnd, 1:N-1)  # add to all but the last time step","category":"page"},{"location":"constraints.html#Defined-Constraints","page":"3. Creating Constraints","title":"Defined Constraints","text":"","category":"section"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"The following constraints are currently defined. See their individual docstrings on details on how to construct them, since constraint constructors are, in general, unique to the constraint.","category":"page"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"GoalConstraint\nLinearConstraint\nCircleConstraint\nSphereConstraint\nCollisionConstraint\nNormConstraint\nBoundConstraint\nIndexedConstraint","category":"page"},{"location":"constraints.html#Working-with-ConstraintList","page":"3. Creating Constraints","title":"Working with ConstraintList","text":"","category":"section"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"The ConstraintList type is useful type that provides some convenient methods for manipulating and working with the constraints in your trajectory optimization problem.","category":"page"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"It supports many of the operations that work on an AbstractVector, such as length, indexing (e.g. cons[1] or cons[end]), and iteration (e.g. [con for con in cons]).","category":"page"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"The time step indices can be retrieved via constraintindices, e.g. constraintindices(cons, 1), which returns the indices for the first constraint. You can also iterate over constraints and their time indices simultaneously using zip(::ConstraintList), e.g.  [(length(con), length(inds)) for (inds,con) in zip(cons)]. ","category":"page"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"The num_constraints(::ConstraintList) returns a vector of length N with total number of constraint values per time step. Note that since each constraint is vector-valued, this is different than  length(::ConstraintList). The total number of dual variables can be calculated using sum(num_constraints(cons)).","category":"page"},{"location":"model.html","page":"1. Setting Up a Dynamics Model","title":"1. Setting Up a Dynamics Model","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"model.html#.-Setting-Up-a-Dynamics-Model","page":"1. Setting Up a Dynamics Model","title":"1. Setting Up a Dynamics Model","text":"","category":"section"},{"location":"model.html","page":"1. Setting Up a Dynamics Model","title":"1. Setting Up a Dynamics Model","text":"TrajectoryOptimization relies on the interface defined by RobotDynamics.jl to define the forced dynamics required to solve the problem. Please refer to the documentation for more details on setting up and defining models. We present a simple example here.","category":"page"},{"location":"model.html","page":"1. Setting Up a Dynamics Model","title":"1. Setting Up a Dynamics Model","text":"Assume we want to find an optimal trajectory for the canonical cartpole system. We can either import an existing model defined in RobotZoo.jl or use RobotDynamics.jl to define our own. Defining our own model is pretty straight-forward:","category":"page"},{"location":"model.html","page":"1. Setting Up a Dynamics Model","title":"1. Setting Up a Dynamics Model","text":"using RobotDynamics\nusing ForwardDiff\nusing FiniteDiff\nusing StaticArrays\n\nRobotDynamics.@autodiff struct Cartpole{T} <: RobotDynamics.ContinuousDynamics\n    mc::T\n    mp::T\n    l::T\n    g::T\nend\n\nCartpole() = Cartpole(1.0, 0.2, 0.5, 9.81)\n\nRobotDynamics.state_dim(::Cartpole) = 4\nRobotDynamics.control_dim(::Cartpole) = 1\n\nfunction RobotDynamics.dynamics(model::Cartpole, x, u)\n    mc = model.mc   # mass of the cart in kg (10)\n    mp = model.mp   # mass of the pole (point mass at the end) in kg\n    l = model.l     # length of the pole in m\n    g = model.g     # gravity m/s^2\n\n    q  = x[ SA[1,2] ]  # SA[...] creates a StaticArray.\n    qd = x[ SA[3,4] ]\n\n    s = sin(q[2])\n    c = cos(q[2])\n\n    H = @SMatrix [mc+mp mp*l*c; mp*l*c mp*l^2]\n    C = @SMatrix [0 -mp*qd[2]*l*s; 0 0]\n    G = @SVector [0, mp*g*l*s]\n    B = @SVector [1, 0]\n\n    qdd = -H\\(C*qd + G - B*u[1])\n    return [qd; qdd]\nend\n\nfunction RobotDynamics.dynamics!(model::Cartpole, xdot, x, u)\n    xstatic = SA[x[1], x[2], x[3], x[4]]\n    ustatic = SA[u[1]]\n    xdot .= RobotDynamics.dynamics(model, xstatic, ustatic)\n    return nothing\nend","category":"page"},{"location":"model.html","page":"1. Setting Up a Dynamics Model","title":"1. Setting Up a Dynamics Model","text":"with our dynamics model defined, we are ready to start setting up the optimization problem.","category":"page"},{"location":"model.html","page":"1. Setting Up a Dynamics Model","title":"1. Setting Up a Dynamics Model","text":"tip: Tip\nFor best performance, use StaticArrays.jl, which offers loop-unrolling and allocation-free methods for  small to medium-sized matrices and vectors. For systems with  large state vectors, prefer to use the in-place methods (the ones that end in !).","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"creating_problems.html#problem_section","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"","category":"section"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"The Problem contains all of the information needed to solve a trajectory optimization problem. At a minimum, this is the model, objective, and initial condition. A Problem is passed to a solver, which extracts needed information, and may or may or not modify its internal representation of the problem in order to solve it (e.g. the Augmented Lagrangian solver combines the constraints and objective into a single Augmented Lagrangian objective.)","category":"page"},{"location":"creating_problems.html#Creating-a-Problem","page":"4. Setting up a Problem","title":"Creating a Problem","text":"","category":"section"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"Let's say we're trying to solve the following trajectory optimization problem:","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"beginaligned\n  min_x_0Nu_0N-1 quad  (x_N-x_f)^T Q_f (x_N-x_f) + sum_k=0^N-1 (x_k-x_f)^T Q (x_k - x_f) + u^T R u  \n  textrmst            quad  x_k+1 = f(x_k u_k) \n                                  u_k leq 3 \n                                  x_N = x_f \nendaligned","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"We'll quickly set up the dynamics, objective, and constraints. See previous sections for more details on how to do this.","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"using TrajectoryOptimization\nusing RobotDynamics\nusing RobotZoo: Cartpole\nusing StaticArrays, LinearAlgebra\n\n# Dynamics and Constants\nmodel = Cartpole()\nn,m = RobotDynamics.dims(model)\nN = 101   # number of knot points\ntf = 5.0  # final time\nx0 = @SVector [0, 0, 0, 0.]  # initial state\nxf = @SVector [0, π, 0, 0.]  # goal state (i.e. swing up)\n\n# Objective\nQ = Diagonal(@SVector fill(1e-2,n))\nR = Diagonal(@SVector fill(1e-1,m))\nQf = Diagonal(@SVector fill(100.,n))\nobj = LQRObjective(Q, R, Qf, xf, N)\n\n# Constraints\nconSet = ConstraintList(n,m,N)\nbnd = BoundConstraint(n,m, u_min=-3.0, u_max=3.0)\ngoal = GoalConstraint(xf)\nadd_constraint!(conSet, bnd, 1:N-1)\nadd_constraint!(conSet, goal, N:N)","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"The following method is the easiest way to set up a trajectory optimization problem:","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"prob = Problem(model, obj, x0, tf, constraints=conSet, xf=xf, integration=RK4)","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"where the keyword arguments are, of course, optional.","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"This constructor has the following arguments:","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"(required) model::RobotDynamics.AbstractModel - dynamics model. Can also ","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"be a vector of RobotDynamics.DiscreteDynamics of length N-1.","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"(required) obj::AbstractObjective - objective function\n(required) x0::AbstractVector - initial state \n(required) tf::AbstractFloat - final time\n(optional) constraints::ConstraintSet - constraint set. Default is no constraints.\n(optional) xf::AbstractVector - Goal state.\n(optional) N::Int - number of knot points. Default is given by length of objective.\n(optional) dt::AbstractFloat - Time step length. Can be either a scalar or a vector of length N-1. Default is calculated using tf and N.\n(optional) integration::RobotDynamics.QuadratureRule - Quadrature rule for discretizing the dynamics. Default is given by RobotDynamics.RK4.\n(optional) X0 - Initial guess for state trajectory. Can either be a matrix of size (n,N) or a vector of length N of n-dimensional vectors.\n(optional) U0 - Initial guess for control trajectory. Can either be a matrix of size (m,N) or a vector of length N-1 of n-dimensional vectors.","category":"page"},{"location":"creating_problems.html#Initialization","page":"4. Setting up a Problem","title":"Initialization","text":"","category":"section"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"A good initialization is critical to getting good results for nonlinear optimization problems. TrajectoryOptimization.jl current supports initialization of the state and control trajectories. Initialization of dual variables (i.e. Lagrange multipliers) is not yet support but will be included in the near future. The state and control trajectories can be initialized directly in the constructor using the X0 and U0 keyword arguments described above, or using the following methods:","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"initial_states!\ninitial_controls!","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"where, again, these can either be matrices or vectors of vectors of the appropriate size. It should be noted that these methods work on either Problems or instances of AbstractSolver.","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"Alternatively, the problem can be initialized with both the state and control trajectories by passing in a RobotDynamics.SampledTrajectory  via initial_trajectory!.","category":"page"},{"location":"creating_problems.html#Getters","page":"4. Setting up a Problem","title":"Getters","text":"","category":"section"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"The following methods can be used to get information out of the problem  definition","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"gettimes(::Problem)\nget_initial_time\nget_final_time\nget_constraints\nget_model\nget_objective\nget_trajectory\nget_initial_state\nget_final_state\ngettimes","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"To query the state and control dimensions along the trajectory, the preferred method is to one of ","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"RobotDynamics.state_dim(prob, k)\nRobotDynamics.control_dim(prob, k)\nRobotDynamics.dims(prob, k)","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"which return n, m, or the tuple n,m,N for the state and control  dimensions at time step k, and the horizon length N.","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"Alternatively, you can get the state and control dimensions as vectors of  length N by omitting the time step k.","category":"page"},{"location":"creating_problems.html#Extracting-states-and-controls","page":"4. Setting up a Problem","title":"Extracting states and controls","text":"","category":"section"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"To extract the state and control trajectories, the Problem type supports the same methods as RobotDynamics.SampledTrajectory, e.g.","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"states(prob)         # return a vector of state vectors\ncontrol(prob)        # return a vector of control vectors\nstates(prob, k)      # get a vector of the `k`th element of the state vector\ncontrols(prob, i:j)  # get a vector the vectors of elements `i` through `j` of the controls vector. ","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"tip: Tip\nTo convert a vector of vectors to a 2D array, use:Xmat = hcat(Vector.(X)...)Note that converting to a vector is a safe way to avoid the expensive  operation of concatenating a bunch of static vectors, if the elements of  X are a subtype of StaticArrays.StaticVector.","category":"page"},{"location":"creating_problems.html#Other-Methods","page":"4. Setting up a Problem","title":"Other Methods","text":"","category":"section"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"The cost of the current trajectory can be evaluated using cost. The initial state and the current controls trajectory can be used to simulate the system forward (open-loop) to obtain a state trajectory via  rollout!.","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"For MPC applications, the following methods can be useful:","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"RobotDynamics.setinitialtime!(prob, t0)\nset_initial_state!\nset_goal_state!","category":"page"},{"location":"problem.html","page":"Problem","title":"Problem","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"problem.html#problem_api","page":"Problem","title":"Problem","text":"","category":"section"},{"location":"problem.html","page":"Problem","title":"Problem","text":"Pages = [\"problem.md\"]","category":"page"},{"location":"problem.html#Definition","page":"Problem","title":"Definition","text":"","category":"section"},{"location":"problem.html","page":"Problem","title":"Problem","text":"Problem","category":"page"},{"location":"problem.html#TrajectoryOptimization.Problem","page":"Problem","title":"TrajectoryOptimization.Problem","text":"Problem{T}\n\nTrajectory Optimization Problem. Contains the full definition of a trajectory optimization problem, including:\n\ndynamics model (RD.DiscreteDynamics)\nobjective (Objective)\nconstraints (ConstraintList)\ninitial and final states\nPrimal variables (state and control trajectories)\nDiscretization information: knot points (N), time step (dt), and total time (tf)\n\nConstructors:\n\nProblem(model, obj, constraints, x0, xf, Z, N, tf)\nProblem(model, obj, x0, tf; [xf, constraints, N, X0, U0, dt, integration])\n\nwhere Z is a [RobotDynamics.SampledTrajectory].\n\nArguments\n\nmodel: A DiscreteDynamics model. If a ContinuousDynamics model is provided, it will          be converted to a DiscretizedDynamics model via the integrator specified by the          integration keyword argument.\nobj: Objective\nX0: Initial state trajectory. If omitted it will be initialized with NaNs, to be later overwritten by the solver.\nU0: Initial control trajectory. If omitted it will be initialized with zeros.\nx0: Initial state\nxf: Final state. Defaults to zeros.\ndt: Time step. Can be either a vector of length N-1 or a positive real number.\ntf: Final time. Set to zero.\nN: Number of knot points. Uses the length of the objective.\nintegration: One of the defined integration types to discretize the continuous dynamics model.\n\nBoth X0 and U0 can be either a Matrix or a Vector{<:AbstractVector}.\n\n\n\n\n\n","category":"type"},{"location":"problem.html#Methods","page":"Problem","title":"Methods","text":"","category":"section"},{"location":"problem.html#Getters","page":"Problem","title":"Getters","text":"","category":"section"},{"location":"problem.html","page":"Problem","title":"Problem","text":"cost(::Problem)\nstates(::Problem)\ncontrols(::Problem)\nhorizonlength\nget_objective\nget_constraints\nget_model\nget_trajectory\nget_initial_time\nget_final_time\nget_initial_state\nget_final_state\nis_constrained\ngettimes","category":"page"},{"location":"problem.html#TrajectoryOptimization.cost-Tuple{Problem}","page":"Problem","title":"TrajectoryOptimization.cost","text":"cost(::Problem)\n\nCompute the cost for the current trajectory\n\n\n\n\n\n","category":"method"},{"location":"problem.html#RobotDynamics.states-Tuple{Problem}","page":"Problem","title":"RobotDynamics.states","text":"states(::Problem, args...)\n\nGet the state trajectory.\n\n\n\n\n\n","category":"method"},{"location":"problem.html#RobotDynamics.controls-Tuple{Problem}","page":"Problem","title":"RobotDynamics.controls","text":"controls(::Problem, args...)\n\nGet the control trajectory\n\n\n\n\n\n","category":"method"},{"location":"problem.html#TrajectoryOptimization.horizonlength","page":"Problem","title":"TrajectoryOptimization.horizonlength","text":"horizonlength(prob::Problem)\n\nNumber of knot points in the time horizon, i.e. the length of the sampled  state and control trajectories.\n\n\n\n\n\n","category":"function"},{"location":"problem.html#TrajectoryOptimization.get_objective","page":"Problem","title":"TrajectoryOptimization.get_objective","text":"Get the objective. Returns an AbstractObjective.\n\n\n\n\n\n","category":"function"},{"location":"problem.html#TrajectoryOptimization.get_constraints","page":"Problem","title":"TrajectoryOptimization.get_constraints","text":"Get problem constraints. Returns ConstraintList.\n\n\n\n\n\n","category":"function"},{"location":"problem.html#TrajectoryOptimization.get_model","page":"Problem","title":"TrajectoryOptimization.get_model","text":"get_model(prob::Problem)\n\nGet the dynamics models used at each time step.  Returns Vector{RobotDynamics.DiscreteDynamics}.\n\n\n\n\n\nget_model(prob::Problem, k::Integer)\n\nGet the dynamics model at time step k.\n\n\n\n\n\n","category":"function"},{"location":"problem.html#TrajectoryOptimization.get_trajectory","page":"Problem","title":"TrajectoryOptimization.get_trajectory","text":"Get the trajectory. Returns an RobotDynamics.SampledTrajectory\n\n\n\n\n\n","category":"function"},{"location":"problem.html#TrajectoryOptimization.get_initial_time","page":"Problem","title":"TrajectoryOptimization.get_initial_time","text":"get_initial_time(problem)\n\nGet the initial time of the trajectory.\n\n\n\n\n\n","category":"function"},{"location":"problem.html#TrajectoryOptimization.get_final_time","page":"Problem","title":"TrajectoryOptimization.get_final_time","text":"get_final_time(problem)\n\nGet the final time of the trajectory.\n\n\n\n\n\n","category":"function"},{"location":"problem.html#TrajectoryOptimization.get_initial_state","page":"Problem","title":"TrajectoryOptimization.get_initial_state","text":"Get the in initial state. Returns an AbstractVector.\n\n\n\n\n\n","category":"function"},{"location":"problem.html#TrajectoryOptimization.get_final_state","page":"Problem","title":"TrajectoryOptimization.get_final_state","text":"Get the in initial state. Returns an AbstractVector.\n\n\n\n\n\n","category":"function"},{"location":"problem.html#TrajectoryOptimization.is_constrained","page":"Problem","title":"TrajectoryOptimization.is_constrained","text":"Determines if the problem is constrained.\n\n\n\n\n\n","category":"function"},{"location":"problem.html#RobotDynamics.gettimes","page":"Problem","title":"RobotDynamics.gettimes","text":"gettimes(Z)\n\nGet a vector of times for the entire trajectory.\n\n\n\n\n\ngettimes(::Problem)\n\nGet the times for all the knot points in the problem.\n\n\n\n\n\n","category":"function"},{"location":"problem.html#Setters","page":"Problem","title":"Setters","text":"","category":"section"},{"location":"problem.html","page":"Problem","title":"Problem","text":"initial_controls!(::Problem, X0::Vector{<:AbstractVector})\ninitial_states!(::Problem, U0::Vector{<:AbstractVector})\ninitial_trajectory!\nset_initial_state!\nset_goal_state!","category":"page"},{"location":"problem.html#TrajectoryOptimization.initial_controls!-Tuple{Problem, Vector{var\"#s28\"} where var\"#s28\"<:(AbstractVector{T} where T)}","page":"Problem","title":"TrajectoryOptimization.initial_controls!","text":"initial_controls!(::Problem, U0::Vector{<:AbstractVector})\ninitial_controls!(::Problem, U0::AbstractMatrx)\n\nCopy the control trajectory\n\n\n\n\n\n","category":"method"},{"location":"problem.html#TrajectoryOptimization.initial_states!-Tuple{Problem, Vector{var\"#s28\"} where var\"#s28\"<:(AbstractVector{T} where T)}","page":"Problem","title":"TrajectoryOptimization.initial_states!","text":"initial_states!(::Problem, X0::Vector{<:AbstractVector})\ninitial_states!(::Problem, X0::AbstractMatrix)\n\nCopy the state trajectory\n\n\n\n\n\n","category":"method"},{"location":"problem.html#TrajectoryOptimization.initial_trajectory!","page":"Problem","title":"TrajectoryOptimization.initial_trajectory!","text":"initial_trajectory!(prob::Problem, Z)\n\nCopies the trajectory data from Z to the problem.\n\n\n\n\n\n","category":"function"},{"location":"problem.html#TrajectoryOptimization.set_initial_state!","page":"Problem","title":"TrajectoryOptimization.set_initial_state!","text":"set_initial_state!(prob::Problem, x0::AbstractVector)\n\nSet the initial state in prob to x0\n\n\n\n\n\n","category":"function"},{"location":"problem.html#TrajectoryOptimization.set_goal_state!","page":"Problem","title":"TrajectoryOptimization.set_goal_state!","text":"set_goal_state!(prob::Problem, xf::AbstractVector; objective=true, constraint=true)\n\nChange the goal state. If the appropriate flags are true, it will also modify a  GoalConstraint and the objective, assuming it's an LQRObjective.\n\n\n\n\n\n","category":"function"},{"location":"problem.html#Other","page":"Problem","title":"Other","text":"","category":"section"},{"location":"problem.html","page":"Problem","title":"Problem","text":"rollout!","category":"page"},{"location":"problem.html#RobotDynamics.rollout!","page":"Problem","title":"RobotDynamics.rollout!","text":"rollout!(::Problem)\n\nSimulate the dynamics forward from the initial condition x0 using the controls in the trajectory Z. If a problem is passed in, Z = prob.Z, model = prob.model, and x0 = prob.x0.\n\n\n\n\n\n","category":"function"},{"location":"costfunction_interface.html","page":"Cost Function Interface","title":"Cost Function Interface","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"costfunction_interface.html","page":"Cost Function Interface","title":"Cost Function Interface","text":"All cost functions in TrajectoryOptimization.jl inherit from  RobotDynamics.ScalarFunction, and leverage that interface. This allows  the RobotDynamics.@autodiff method to be used to automatically generate efficient methods to evaluate the gradient and Hessian. ","category":"page"},{"location":"costfunction_interface.html","page":"Cost Function Interface","title":"Cost Function Interface","text":"We give an example of defining a new user-defined cost function in the  example below, to illustrate how the interface works.","category":"page"},{"location":"costfunction_interface.html#cost_interface","page":"Cost Function Interface","title":"Cost Function Interface","text":"","category":"section"},{"location":"costfunction_interface.html","page":"Cost Function Interface","title":"Cost Function Interface","text":"Here we define a nonlinear cost function for the cartpole system:","category":"page"},{"location":"costfunction_interface.html","page":"Cost Function Interface","title":"Cost Function Interface","text":"    Q_2 * cos(theta  2) + frac12 (Q_1 y^2 + Q_3 doty^2 + Q_4 dottheta^2) + frac12 R ^2","category":"page"},{"location":"costfunction_interface.html","page":"Cost Function Interface","title":"Cost Function Interface","text":"We just need to define a new struct that inherits from TrajectoryOptimization.CostFunction and implements the methods required by the AbstractFunction interface: ","category":"page"},{"location":"costfunction_interface.html","page":"Cost Function Interface","title":"Cost Function Interface","text":"using TrajectoryOptimization\nusing RobotDynamics\nusing ForwardDiff\nusing FiniteDiff\n\nRobotDynamics.@autodiff struct CartpoleCost{T} <: TrajectoryOptimization.CostFunction\n    Q::Vector{T}\n    R::Vector{T}\nend\n\nRobotDynamics.state_dim(::CartpoleCost) = 4\nRobotDynamics.control_dim(::CartpoleCost) = 1\n\nfunction RobotDynamics.evaluate(cost::CartpoleCost, x, u)\n    y = x[1]\n    θ = x[2]\n    ydot = x[3]\n    θdot = x[4]\n    J = cost.Q[2] * cos(θ/2)\n    J += 0.5* (cost.Q[1] * y^2 + cost.Q[3] * ydot^2 + cost.Q[4] * θdot^2)\n    if !isempty(u)\n        J += 0.5 * cost.R[1] * u[1]^2 \n    end\n    return J\nend","category":"page"},{"location":"costfunction_interface.html","page":"Cost Function Interface","title":"Cost Function Interface","text":"note: Note\nNote that we check to see if u was empty, which can be the case at the last time step, depending on how a solver handles this case. It's usually a good idea to add a check like this.","category":"page"},{"location":"costfunction_interface.html","page":"Cost Function Interface","title":"Cost Function Interface","text":"tip: Tip\nThe RobotDynamics.@autodiff macro automatically defines the gradient! and hessian! methods from RobotDynamics.jl for us, using ForwardDiff.jl and FiniteDiff.jl.","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"quickstart.html#quickstart_page","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"This page provides a quick overview of the API to help you get started quickly.  It also points to other places in the documentation to help you get more  details.","category":"page"},{"location":"quickstart.html#Step-1:-Define-the-Dynamics-Model","page":"Quickstart","title":"Step 1: Define the Dynamics Model","text":"","category":"section"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"Define the dynamics model. See documentation for  RobotDynamics.jl  for more details.","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"using TrajectoryOptimization\nusing RobotDynamics\nusing StaticArrays\nusing LinearAlgebra\nusing RobotDynamics\nusing Test\nconst TO = TrajectoryOptimization\nconst RD = RobotDynamics\n\n## Model Definition\nstruct DoubleIntegrator{T} <: RD.ContinuousDynamics \n    mass::T\nend\n\nfunction RD.dynamics(model::DoubleIntegrator, x, u)\n    mass = model.mass\n    vx,vy = x[3], x[4]\n    ax,ay = u[1] / mass, u[2] / mass\n    SA[vx, vy, ax, ay]\nend\n\nRD.state_dim(::DoubleIntegrator) = 4\nRD.control_dim(::DoubleIntegrator) = 2","category":"page"},{"location":"quickstart.html#Step-2:-Define-the-Discretization","page":"Quickstart","title":"Step 2: Define the Discretization","text":"","category":"section"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"The next step is to instantiate our model, discretize it, if necessary, and  define the number of knot points to use and time horizon.","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"model = DoubleIntegrator(1.0)\ndmodel = RD.DiscretizedDynamics{RD.RK4}(model)\nn,m = RD.dims(model)\ntf = 3.0         # final time (sec)\nN = 21           # number of knot points\ndt = tf / (N-1)  # time step (sec)","category":"page"},{"location":"quickstart.html#Step-3:-Define-the-Objective","page":"Quickstart","title":"Step 3: Define the Objective","text":"","category":"section"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"We now define our objective. See Setting up an Objective Cost Function Inteface, and the Cost/Objective API.","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"# Objective\nx0 = SA[0,0.,0,0]  # initial state\nxf = SA[0,2.,0,0]  # final state\n\nQ = Diagonal(@SVector ones(n))\nR = Diagonal(@SVector ones(m))\nQf = Q*(N-1)\nobj = LQRObjective(Q, R, Qf, xf, N)","category":"page"},{"location":"quickstart.html#Step-4:-Define-constraints","page":"Quickstart","title":"Step 4: Define constraints","text":"","category":"section"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"The next step is to define any constraints we want to add to our trajectory  optimization problem. Here we define the following constraints:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"A constraint to get to the goal\nA single circular obstacle at (0,1.0) with radius 0.5\nNorm constraint on the controls: ||u||₂ <= 5.0\nBounds the controls between -10 and 10","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"See Creating Constraints, Constraint Interface, and the Constraint API for more details.","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"cons = ConstraintList(n,m,N)\nadd_constraint!(cons, GoalConstraint(xf), N)\nadd_constraint!(cons, CircleConstraint(n, SA[0.0], SA[1.0], SA[0.5]), 2:N-1)\nadd_constraint!(cons, NormConstraint(n, m, 5.0, TO.SecondOrderCone(), :control), 1:N-1)\nadd_constraint!(cons, BoundConstraint(n,m, u_min=-10, u_max=10), 1:N-1)","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"note: Note\nNote that the time indices are chosen to avoid redundant constraints at the  first and last time steps.","category":"page"},{"location":"quickstart.html#Step-5:-Create-the-Problem","page":"Quickstart","title":"Step 5: Create the Problem","text":"","category":"section"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"The last step is to actually create the problem by passing all of the information  we defined previously to the constructor. See  Setting up a Problem and the Problem API for more details.","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"# Create problem\nprob = Problem(model, obj, x0, tf, xf=xf, constraints=cons)","category":"page"},{"location":"quickstart.html#Step-6:-Methods-on-Problems","page":"Quickstart","title":"Step 6: Methods on Problems","text":"","category":"section"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"The following code gives some examples of a few of the methods you can use on a  Problem once it's created.","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"# Set initial controls\nU0 = [randn(m) for k = 1:N]\ninitial_controls!(prob, U0)\n\n# Set initial state\nX0 = [zeros(n) for k = 1:N]\ninitial_states!(prob, X0)\n\n# Evaluate the cost\nJ = cost(prob)\n@test J ≈ mapreduce(+, 1:N) do k\n    if k < N\n        x,u = X0[k], U0[k]\n        0.5 * (x - xf)'Q*(x - xf) + 0.5*u'R*u\n    else\n        x = X0[k]\n        0.5 * (x - xf)'Qf*(x - xf)\n    end\nend\n\n# Simulate the system forward\nrollout!(prob)\n\n# Extract states, controls, and times\nX = states(prob)\nU = controls(prob)\nt = gettimes(prob)\n\nXrollout = [copy(x0) for k = 1:N]\nfor k = 1:N-1\n    Xrollout[k+1] = RD.discrete_dynamics(\n        get_model(prob, k), Xrollout[k], U0[k], dt*(k-1), dt\n    )\nend\n@test Xrollout ≈ X \n\n# Convert to matrices\nXmat = hcat(Vector.(X)...)\nUmat = hcat(Vector.(U)...)\n\n# Extract out individual states and controls\nx1 = states(prob, 2)\nu1 = controls(prob, 1)","category":"page"},{"location":"quickstart.html#Step-7:-Working-with-Constraints","page":"Quickstart","title":"Step 7: Working with Constraints","text":"","category":"section"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"This section provides a few more details and example on how to work with the  constraints we defined previously.","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"The ConstraintList type supports indexing and iteration:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"constraints = get_constraints(prob)\ngoalcon = constraints[1]\ncirclecon = constraints[2]\nnormcon = constraints[3]","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"You can use the zip method to iterate over the constraint and its assigned  indices:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"for (inds,con) in zip(constraints)\n    @show inds\nend","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"You can identify the type of constraint using the  TrajectoryOptimization.sense function, which returns a  ConstraintSense:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"cones = map(TO.sense, constraints)","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"You can get the bounds of each constraint, which are useful when passing  to interfaces like  MathOptInterface  that expect a vector of constraints with upper and lower bounds to encode  equality/inequality constraints.","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"\nlower_bounds = vcat(Vector.(map(TO.lower_bound, constraints))...)\nupper_bounds = vcat(Vector.(map(TO.upper_bound, constraints))...)\n@test lower_bounds ≈ [zeros(n); fill(-Inf, 1); fill(-Inf, m+1); fill(-Inf, n); fill(-10, m)]\n@test upper_bounds ≈ [zeros(n); fill(0.0, 1); fill(+Inf, m+1); fill(+Inf, n); fill(+10, m)]","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"You can use the is_bound function to check to see if the constraint can  be represented as a simple bound constraint on the states or controls:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"is_bound_constraint = map(TO.is_bound, constraints)","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"To evaluate constraints, you use the same interface from AbstractFunction  defined in RobotDynamics:","category":"page"},{"location":"quickstart.html","page":"Quickstart","title":"Quickstart","text":"# Evaluating a single constraint\n# * Note that the `GoalConstraint` is only a function of the state, but\n#   `NormConstraint` is a function of both the state and control\nx,u = rand(model)  # generate some random states and controls\nz = KnotPoint(x, u, 0.0, NaN)\nc = zeros(RD.output_dim(goalcon))\nRD.evaluate(goalcon, x)\nRD.evaluate(goalcon, z)\nRD.evaluate!(goalcon, c, x)\nRD.evaluate!(goalcon, c, z)\n\nc = zeros(RD.output_dim(normcon))\nRD.evaluate(normcon, x, u)\nRD.evaluate(normcon, z)\nRD.evaluate!(normcon, c, x, u)\nRD.evaluate!(normcon, c, z)\n\n# Evaluating the Jacobian for a single constraint\n# * Note that these methods require passing in a KnotPoint type\nJ = TO.gen_jacobian(goalcon)\nc = zeros(RD.output_dim(goalcon))\nRD.jacobian!(RD.StaticReturn(), RD.UserDefined(), goalcon, J, c, z)\n\nJ = TO.gen_jacobian(normcon)\nc = zeros(RD.output_dim(normcon))\nRD.jacobian!(RD.StaticReturn(), RD.UserDefined(), normcon, J, c, z)\n\n# Evaluating constraint at multiple time steps \nZ = get_trajectory(prob)\ninds = constraints.inds[1]\nvals = [zeros(RD.output_dim(goalcon)) for i in inds] \nTO.evaluate_constraints!(RD.StaticReturn(), goalcon, vals, Z, inds)\n\ninds = constraints.inds[2]\nvals = [zeros(RD.output_dim(normcon)) for i in inds] \nTO.evaluate_constraints!(constraints.sigs[2], normcon, vals, Z, inds)\n\n# Evaluating constraint Jacobians at multiple time steps\ninds = constraints.inds[1]\njacs = [TO.gen_jacobian(goalcon) for i in inds] \nvals = [zeros(RD.output_dim(goalcon)) for i in inds] \nTO.constraint_jacobians!(\n    TO.functionsignature(constraints, 1), TO.diffmethod(constraints, 1), \n    goalcon, jacs, vals, Z, inds\n)\n\ninds = constraints.inds[2]\njacs = [TO.gen_jacobian(normcon) for i in inds] \nvals = [zeros(RD.output_dim(normcon)) for i in inds] \nTO.constraint_jacobians!(\n    TO.functionsignature(constraints, 2), TO.diffmethod(constraints, 2), \n    normcon, jacs, vals, Z, inds\n)","category":"page"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"There are a couple of detailed example notebooks in the examples folder.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"For more examples, see the problems included in ALTRO.jl and run as part of it's test suite.","category":"page"},{"location":"cost_api.html","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"cost_api.html#cost_api","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"","category":"section"},{"location":"cost_api.html","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"This page details the functions related to building and evaluating cost functions and objectives.","category":"page"},{"location":"cost_api.html#Cost-Functions","page":"Cost Functions and Objectives","title":"Cost Functions","text":"","category":"section"},{"location":"cost_api.html","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"CostFunction\nQuadraticCostFunction\nDiagonalCost\nQuadraticCost\nLQRCost\nis_diag\nis_blockdiag\ninvert!","category":"page"},{"location":"cost_api.html#TrajectoryOptimization.CostFunction","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.CostFunction","text":"Cost Function\n\nAbstract type that represents a scalar-valued function that accepts a state and control at a single knot point.\n\n\n\n\n\n","category":"type"},{"location":"cost_api.html#TrajectoryOptimization.QuadraticCostFunction","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.QuadraticCostFunction","text":"QuadraticCostFunction\n\nAn abstract type that represents any CostFunction of the form\n\nfrac12 x^T Q x + frac12 u^T R u + u^T H x + q^T x + r^T u + c\n\nThese types all support the following methods\n\nis_diag\nis_blockdiag\ninvert!\n\nAs well as standard addition.\n\n\n\n\n\n","category":"type"},{"location":"cost_api.html#TrajectoryOptimization.DiagonalCost","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.DiagonalCost","text":"DiagonalCost{n,m,T}\n\nCost function of the form\n\nfrac12 x^T Q x + frac12 u^T R u + q^T x + r^T u + c\n\nwhere Q and R are positive semi-definite and positive definite diagonal matrices, respectively, and x is n-dimensional and u is m-dimensional.\n\nConstructors\n\nDiagonalCost(Qd, Rd, q, r, c; kwargs...)\nDiagonalCost(Q, R, q, r, c; kwargs...)\nDiagonalCost(Qd, Rd; [q, r, c, kwargs...])\nDiagonalCost(Q, R; [q, r, c, kwargs...])\n\nwhere Qd and Rd are the diagonal vectors, and Q and R are matrices.\n\nAny optional or omitted values will be set to zero(s). The keyword arguments are\n\nterminal - A Bool specifying if the cost function is terminal cost or not.\nchecks - A Bool specifying if Q and R will be checked for the required definiteness.\n\n\n\n\n\n","category":"type"},{"location":"cost_api.html#TrajectoryOptimization.QuadraticCost","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.QuadraticCost","text":"QuadraticCost{n,m,T,TQ,TR}\n\nCost function of the form\n\nfrac12 x^T Q x + frac12 u^T R u + u^T H x + q^T x + r^T u + c\n\nwhere R must be positive definite, Q and Q_f must be positive semidefinite.\n\nThe type parameters TQ and TR specify the type of Q and R.\n\nConstructor\n\nQuadraticCost(Q, R, H, q, r, c; kwargs...)\nQuadraticCost(Q, R; H, q, r, c, kwargs...)\n\nAny optional or omitted values will be set to zero(s). The keyword arguments are\n\nterminal - A Bool specifying if the cost function is terminal cost or not.\nchecks - A Bool specifying if Q and R will be checked for the required definiteness.\n\n\n\n\n\n","category":"type"},{"location":"cost_api.html#TrajectoryOptimization.LQRCost","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.LQRCost","text":"LQRCost(Q, R, xf, [uf; kwargs...])\n\nConvenience constructor for a QuadraticCostFunction of the form:\n\nfrac12 (x-x_f)^T Q (x-xf) + frac12 (u-u_f)^T R (u-u_f)\n\nIf Q and R are diagonal, the output will be a DiagonalCost, otherwise it will be a QuadraticCost.\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.is_diag","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.is_diag","text":"is_diag(::QuadraticCostFunction)\n\nDetermines if the hessian of a quadratic cost function is strictly diagonal.\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.is_blockdiag","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.is_blockdiag","text":"is_diag(::QuadraticCostFunction)\n\nDetermines if the hessian of a quadratic cost function is block diagonal (i.e. norm(H) = 0).\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.invert!","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.invert!","text":"invert!(Ginv, cost::QuadraticCostFunction)\n\nInvert the hessian of the cost function, storing the result in Ginv. Performs the inversion     efficiently, depending on the structure of the Hessian (diagonal or block diagonal).\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#Adding-Cost-Functions","page":"Cost Functions and Objectives","title":"Adding Cost Functions","text":"","category":"section"},{"location":"cost_api.html","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"Right now, TrajectoryOptimization supports addition of QuadraticCosts, but extensions to general cost function addition should be straightforward, as long as the cost function all have the same state and control dimensions.","category":"page"},{"location":"cost_api.html","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"Adding quadratic cost functions:","category":"page"},{"location":"cost_api.html","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"n,m = 4,5\nQ1 = Diagonal(@SVector [1.0, 1.0, 1.0, 1.0, 0.0])\nR1 = Diagonal(@SVector [1.0, 0.0, 0.0, 0.0, 0.0, 0.0])\nQ2 = Diagonal(@SVector [1.0, 1.0, 1.0, 1.0, 2.0])\nR2 = Diagonal(@SVector [0.0, 1.0, 1.0, 1.0, 1.0, 1.0])\ncost1 = QuadraticCost(Q1, R1)\ncost2 = QuadraticCost(Q2, R2)\ncost3 = cost1 + cost2\n# cost3 is equivalent to QuadraticCost(Q1+Q2, R1+R2)","category":"page"},{"location":"cost_api.html#Objectives","page":"Cost Functions and Objectives","title":"Objectives","text":"","category":"section"},{"location":"cost_api.html","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"Objective\nLQRObjective\nget_J\nTrackingObjective\nupdate_trajectory!","category":"page"},{"location":"cost_api.html#TrajectoryOptimization.Objective","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.Objective","text":"Objective{C}\n\nObjective: stores stage cost(s) and terminal cost functions. All the cost functions at each time step must have the same type.\n\nConstructors:\n\nObjective(cost, N)\nObjective(cost, cost_term, N)\nObjective(costs::Vector{<:CostFunction}, cost_term)\nObjective(costs::Vector{<:CostFunction})\n\n\n\n\n\n","category":"type"},{"location":"cost_api.html#TrajectoryOptimization.LQRObjective","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.LQRObjective","text":"LQRObjective(Q, R, Qf, xf, N)\n\nCreate an objective of the form (x_N - x_f)^T Q_f (x_N - x_f) + sum_k=0^N-1 (x_k-x_f)^T Q (x_k-x_f) + u_k^T R u_k\n\nWhere eltype(obj) <: DiagonalCost if Q, R, and Qf are     Union{Diagonal{<:Any,<:StaticVector}}, <:StaticVector}\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.get_J","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.get_J","text":"Get the vector of costs at each knot point. sum(get_J(obj)) is equal to the cost\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.TrackingObjective","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.TrackingObjective","text":"TrackingObjective(Q, R, Z; [Qf])\n\nGenerate a quadratic objective that tracks the reference trajectory specified by Z.\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.update_trajectory!","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.update_trajectory!","text":"update_trajectory!(obj, Z, [start=1])\n\nFor use with a tracking-style trajectory (see TrackingObjective). Update the costs to track the new trajectory Z. The start parameter specifies the  index of reference trajectory that should be used as the starting point of the reference  tracked by the objective. This is useful when a single, long time-horizon trajectory is given but the optimization only tracks a portion of the reference at each solve (e.g. MPC).\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#Evaluating-the-Cost","page":"Cost Functions and Objectives","title":"Evaluating the Cost","text":"","category":"section"},{"location":"cost_api.html","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"cost","category":"page"},{"location":"cost_api.html#TrajectoryOptimization.cost","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.cost","text":"cost(obj::Objective, Z::SampledTrajectory)\n\nEvaluate the cost for a trajectory. \n\n\n\n\n\ncost(::Problem)\n\nCompute the cost for the current trajectory\n\n\n\n\n\n","category":"function"},{"location":"index.html#TrajectoryOptimization.jl-Documentation","page":"Introduction","title":"TrajectoryOptimization.jl Documentation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Documentation for TrajectoryOptimization.jl","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Pages = [\"index.md\"]","category":"page"},{"location":"index.html#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This package facilitates the definition and evaluation of trajectory optimization problems. Importantly, this package should be considered more of a modeling framework than an optimization solver, similar to Convex.jl. While general trajectory optimization problems are nonconvex, primarily due to the presence of nonlinear equality constraints imposed by the dynamics, they exhibit a unique structure that allows purpose-built solvers such as Altro.jl to gain significant computational savings over the use of more generalized NLP solvers such as SNOPT and Ipopt.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This package deals with trajectory optimization problems of the form,","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"beginaligned\n  min_x_0Nu_0N-1 quad  ell_f(x_N) + sum_k=0^N-1 ell_k(x_k u_k dt) \n  textrmst            quad  x_k+1 = f(x_k u_k) \n                                  g_k(x_ku_k) in mathcalK \n                                  h_k(x_ku_k) = 0\nendaligned","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"where mathcalK is a cone. Right now, only positive/negative orthants  and second-order cones are supported.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Key features include:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Easy and intuitive interface for setting up trajectory optimization problems\nSupport for general, per-timestep constraints\nSupport for Second-Order Cone constraints \nForwardDiff for fast auto-differentiation of dynamics, cost functions, and constraints","category":"page"},{"location":"index.html#Quickstart","page":"Introduction","title":"Quickstart","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"See the Quickstart page for a quick overview of the API.","category":"page"},{"location":"index.html#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"TrajectoryOptimization.jl can be installed via the Julia package manager. Within the Julia REPL:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"] # activate the package manager\n(v1.5) pkg> add TrajectoryOptimization","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"A specific version can be specified using","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(v1.5) pkg> add TrajectoryOptimization@0.4.1","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Or you can check out the main branch with","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(v1.5) pkg> add TrajectoryOptimization#main","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Lastly, if you want to clone the repo into your .julia/dev/ directory for development, you can use","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(v1.5) pkg> dev TrajectoryOptimization","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This will automatically add all package dependencies (see Project.toml). If you want to explicitly use any of these dependencies (such as RobotDynamics.jl),  you'll need to individually add those packages to your environment via the package manager.","category":"page"},{"location":"costfunctions.html#objective_section","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"","category":"section"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Pages = [\"costfunctions.md\"]","category":"page"},{"location":"costfunctions.html#Overview","page":"2. Setting up an Objective","title":"Overview","text":"","category":"section"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"All trajectory optimization problems require a cost function at each stage of the trajectory. Cost functions must be scalar-valued. We assume general cost functions of the form,","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"ell_f(x_N) + sum_k=1^N-1 ell_k(x_ku_k) dt","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"It is very important to note that ell_k(x_ku_k) is ONLY a function of x_k and u_k, i.e. no coupling across time-steps is permitted. This is a requirement for Differential Dynamic Programming methods such as iLQR, but could be relaxed for methods that parameterize both states and controls, such as DIRCOL. In general, any coupling between adjacent time-steps can be resolved by augmenting the state and defining the appropriate dynamics (this is the method we use to solve minimum time problems).","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"In general, trajectory optimization will take a second order Taylor series approximation of the cost function, resulting in a quadratic cost function of the form","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"x_N^T Q_f x_N + q_f^T x_N + sum_k=1^N-1 x_k^T Q_k x_k + q_k^T x_k + u_k^T R_k u_k + r_k^T u_k + u_k^T H_k x_k","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"This type of quadratic cost is typical for trajectory optimization problems, especially when Q is positive semi-definite and R is positive definite, which is strictly convex. These problems behave well and reduce the computational requirements of taking second-order Taylor series expansions of the cost at each iteration.","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"In TrajectoryOptimization.jl we differentiate between the entire objective and the cost functions at each time step. We use Objective to describe the function that is being minimized, which typically consists of a sum of cost functions, with potentially some additional terms (as is the case with augmented Lagrangian objectives). Describing the Objective as a sum of individual functions allows the solvers to more efficiently compute the gradient and Hessian of the entire cost, which is block-diagonal given the Markovianity of the problem.","category":"page"},{"location":"costfunctions.html#Cost-functions","page":"2. Setting up an Objective","title":"Cost functions","text":"","category":"section"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"TrajectoryOptimization.jl currently provide a few useful cost functions. For generic nonlinear cost functions, users are encouraged to define their  own. All cost functions inherit from the general CostFunction type.","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Since quadratic costs are the most standard cost function they excellent place to start. Let's assume we are creating an LQR tracking cost of the form","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"(x_N - x_f)^T Q_f (x_N - x_f) + sum_k=1^N-1 (x_k - x_f)^T Q (x_k - x_f) + u_k^T R u_k","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"for the simple cartpole with the goal of doing a swing-up. To do this we have very convenient method LQRCost.","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"using LinearAlgebra, StaticArrays\nn,m = 4,1\nQ = Diagonal(@SVector fill(0.1,n))\nR = Diagonal(@SVector fill(0.1,m))\nQf = Diagonal(@SVector fill(1000,n))\nxf = @SVector [0,π,0,0]\ncostfun = LQRCost(Q,R,xf)\ncostfun_term = LQRCost(Qf,R*0,xf,terminal=true)","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"tip: Tip\nIt is HIGHLY recommended to specify any special structure, such as Diagonal, especially since these matrices are almost always diagonal. See Julia's built-in LinearAlgebra module for more specialized matrix types.","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"This constructor actually does a simple conversion to turn our cost function into either the generic QuadraticCost or a DiagonalCost. We could do this ourselves:","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"H = @SMatrix zeros(m,n)\nq = -Q*xf\nr = @SVector zeros(m)\nc = xf'Q*xf/2\nqf = -Qf*xf\ncf = xf'Qf*xf/2\ncostfun      = QuadraticCost(Q, R, H, q, r, c)\ncostfun_term = QuadraticCost(Qf, R*0, H, qf, r*0, cf)","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"The QuadraticCost constructor also supports keyword arguments and one that allows for only Q,q and c.:","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"costfun = QuadraticCost(Q, R, q=q, c=c)","category":"page"},{"location":"costfunctions.html#Objective","page":"2. Setting up an Objective","title":"Objective","text":"","category":"section"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Once we have defined the cost function, we can create an objective for our problem by simply copying over all time steps (except for the terminal).","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"# Create an objective from a single cost function\nN = 51\nobj = Objective(costfun, costfun_term, N)","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"There's also a convenient constructor that skips all the previous steps and builds the objective directly, see LQRObjective.","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"obj = LQRObjective(Q, R, Qf, xf, N)","category":"page"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"constraint_interface.html#Constraint-Interface","page":"Constraint Interface","title":"Constraint Interface","text":"","category":"section"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"All constraints inherit from AbstractConstraint.","category":"page"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"AbstractConstraint","category":"page"},{"location":"constraint_interface.html#TrajectoryOptimization.AbstractConstraint","page":"Constraint Interface","title":"TrajectoryOptimization.AbstractConstraint","text":"AbstractConstraint <: RobotDynamics.AbstractFunction\n\nAbstract vector-valued constraint for a trajectory optimization problem. Defined using the AbstractFunction interface from RobotDynamics.jl which  allows for a flexible API for using in-place or out-of-place evaluation,  multiple methods for evaluating Jacobians, etc.\n\nThe \"sense\" of a constraint is specified by defining the ConstraintSense trait on the type, accessed via TrajectoryOptimization.sense, which defines  whether the constraint is an equality, inequality, or conic constraint.\n\nInterface: Any constraint must implement the following interface:\n\nn = RobotDynamics.state_dim(::MyCon)\nm = RobotDynamics.control_dim(::MyCon)\np = RobotDynamics.output_dim(::MyCon)\nTrajectoryOptimization.sense(::MyCon)::ConstraintSense\nc = RobotDynamics.evaluate(::MyCon, x, u)\nRobotDynamics.evaluate!(::MyCon, c, x, u)\n\nConstraints \n\nAll constraints are categorized into the following type tree:\n\n          AbstractConstraint\n                  ↓\n           StageConstraint\n            ↙            ↘ \nStageConstraint       ControlConstraint\n\nThe state and control dimensions (where applicable) can be queried using state_dim(::AbstractConstraint) and control_dim(::AbstractConstraint). The dimensions of a constraint can be verified using check_dims.\n\nThe width of the Jacobian is specified by whether the constraint inherits  from StageConstraint, StateConstraint, or ControlConstraint. It can  be generated automatically using gen_jacobian.\n\nEvaluation\n\nAll constraints can be evaluated by using one of these methods using a  KnotPoint:\n\nRobotDynamics.evaluate(::MyCon, z::AbstractKnotPoint)\nRobotDynamics.evaluate!(::MyCon, c, z::AbstractKnotPoint)\n\nAlternatively, a StageConstraint can be evaluated using\n\nRobotDynamics.evaluate(::MyCon, x, u)\nRobotDynamics.evaluate!(::MyCon, c, x, u)\n\na StateConstraint can be evaluated using\n\nRobotDynamics.evaluate(::MyCon, x)\nRobotDynamics.evaluate!(::MyCon, c, x)\n\nand a ControlConstraint can be evaluated using\n\nRobotDynamics.evaluate(::MyCon, u)\nRobotDynamics.evaluate!(::MyCon, c, u)\n\nJacobian Evaluation\n\nThe Jacobian for all types of constraints can be evaluated using \n\nRobotDynamics.jacobian!(::FunctionSignature, ::DiffMethod, ::MyCon, J, c, z)\n\nwhere z is an AbstractKnotPoint. To define custom Jacobians, one of the following methods must be defined:\n\nRobotDynamics.jacobian!(::MyCon, J, c, z)     # All constraints \nRobotDynamics.jacobian!(::MyCon, J, c, x, u)  # StageConstraint only\nRobotDynamics.jacobian!(::MyCon, J, c, x)     # StateConstraint only\nRobotDynamics.jacobian!(::MyCon, J, c, u)     # ControlConstraint only\n\nThe most specific methods are preferred over those that accept only an AbstractKnotPoint.\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#Constraint-Sense","page":"Constraint Interface","title":"Constraint Sense","text":"","category":"section"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"TrajectoryOptimization.jl assumes equality constraints are of the form g(x) = 0,  and that all other constraints are constrained to lie with a specified cone. This  is referred to as the ConstraintSense. The following are currently implemented:","category":"page"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"ConstraintSense\nEquality\nInequality\nZeroCone\nNegativeOrthant\nSecondOrderCone","category":"page"},{"location":"constraint_interface.html#TrajectoryOptimization.ConstraintSense","page":"Constraint Interface","title":"TrajectoryOptimization.ConstraintSense","text":"\"     ConstraintSense\n\nSpecifies the type of the constraint, or in which convex cone it is to be enforced. Valid subtypes are Equality ⟺ ZeroCone, Inequality ⟺ NegativeOrthant, and  SecondOrderCone.\n\nThe sense of a constraint can be queried using sense(::AbstractConstraint)\n\nThe following operations are supported:\n\nBase.in(::ConstraintSense, x::StaticVector). i.e. x ∈ cone\nprojection(::ConstraintSense, x::StaticVector)\n∇projection(::ConstraintSense, J, x::StaticVector)\n∇²projection(::ConstraintSense, J, x::StaticVector, b::StaticVector)\ndualcone(::ConstraintSense)\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.Equality","page":"Constraint Interface","title":"TrajectoryOptimization.Equality","text":"Equality\n\nEquality constraints of the form g(x) = 0. Equivalent to ZeroCone.\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.Inequality","page":"Constraint Interface","title":"TrajectoryOptimization.Inequality","text":"Inequality\n\nInequality constraints of the form h(x) leq 0.  Equivalent to NegativeOrthant.\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.ZeroCone","page":"Constraint Interface","title":"TrajectoryOptimization.ZeroCone","text":"ZeroCone\n\nThe cone whose valid set is only the origin. Equivalent to Equality.\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.NegativeOrthant","page":"Constraint Interface","title":"TrajectoryOptimization.NegativeOrthant","text":"NegativeOrthant\n\nInequality constraints of the form h(x) leq 0. Equivalent to Inequality.\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.SecondOrderCone","page":"Constraint Interface","title":"TrajectoryOptimization.SecondOrderCone","text":"SecondOrderCone\n\nThe second-order cone is defined as  x leq t where x and t are both part of the cone. TrajectoryOptimization assumes the scalar part t is  the last element in the vector.\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#Evaluating-Constraints","page":"Constraint Interface","title":"Evaluating Constraints","text":"","category":"section"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"The following methods are used to evaluate a constraint:","category":"page"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"evaluate_constraints!\nconstraint_jacobians!","category":"page"},{"location":"constraint_interface.html#TrajectoryOptimization.evaluate_constraints!","page":"Constraint Interface","title":"TrajectoryOptimization.evaluate_constraints!","text":"evaluate_constraints!(sig, con, vals, Z, inds)\n\nEvaluate the constraint con using the sig FunctionSignature for the time steps in  inds along trajectory Z, storing the output in vals.\n\nThe vals argument should be a vector with the same length as inds, where each element  is a mutable vector of length RD.output_dim(con).\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.constraint_jacobians!","page":"Constraint Interface","title":"TrajectoryOptimization.constraint_jacobians!","text":"constraint_jacobians!(sig, diffmethod, con, vals, Z, inds)\n\nEvaluate the constraint con using the sig FunctionSignature for the time steps in  inds along trajectory Z, storing the output in vals.\n\nThe vals argument should be a vector with the same length as inds, where each element  is a mutable vector of length RD.output_dim(con).\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#Methods","page":"Constraint Interface","title":"Methods","text":"","category":"section"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"The following methods are defined for all AbstractConstraints","category":"page"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"sense\nupper_bound\nlower_bound\nis_bound\ncheck_dims","category":"page"},{"location":"constraint_interface.html#TrajectoryOptimization.sense","page":"Constraint Interface","title":"TrajectoryOptimization.sense","text":"Get constraint sense (Inequality vs Equality)\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.upper_bound","page":"Constraint Interface","title":"TrajectoryOptimization.upper_bound","text":"upper_bound(constraint)\n\nUpper bound of the constraint, as a vector. This is zero for inequality and equality constraints, and +Inf for SecondOrderCone.\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.lower_bound","page":"Constraint Interface","title":"TrajectoryOptimization.lower_bound","text":"lower_bound(constraint)\n\nLower bound of the constraint, as a vector. This is zero for equality constraints and -Inf for SecondOrderCone and inequality constraints.\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.is_bound","page":"Constraint Interface","title":"TrajectoryOptimization.is_bound","text":"is_bound(constraints)\n\nReturns true if the constraint can be represeted as either\n\n    x_textmin leq x leq x_textmax\n\nor \n\n    u_textmin leq u leq u_textmax\n\ni.e. simple bound constraints on the states and controls.\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.check_dims","page":"Constraint Interface","title":"TrajectoryOptimization.check_dims","text":"check_dims(con, n, m)\n\nCheck whether the constraint is consistent with the specified state and control dimensions.\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#Adding-a-New-Constraint","page":"Constraint Interface","title":"Adding a New Constraint","text":"","category":"section"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"See interface description in documentation for AbstractConstraint. The interface allows for a lot of flexibility, but let's do a simple example. Let's say we have a 2-norm constraint on the controls at each time step, e.g. u leq a. We can do this with just a few lines of code:","category":"page"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"using TrajectoryOptimization\nusing RobotDynamics\nusing ForwardDiff\nusing FiniteDiff\n\nRobotDynamics.@autodiff struct ControlNorm{T} <: TrajectoryOptimization.ControlConstraint\n    m::Int\n    val::T\n    function ControlNorm(m::Int, val::T) where T\n        @assert val ≥ 0 \"Value must be greater than or equal to zero\"\n        new{T}(m,val,sense,inds)\n    end\nend\nRobotDynamics.control_dim(con::ControlNorm) = con.m\nRobotDynamics.output_dim(::ControlNorm) = 1\nTrajectoryOptimization.sense(::ControlNorm) = Inequality()\n\nRobotDynamics.evaluate(con::ControlNorm, u) = SA[norm(u) - con.a] # needs to be a vector output\nRobotDynamics.evaluate!(con::ControlNorm, c, u) = SA[norm(u) - con.a]\n\nfunction RobotDynamics.jacobian!(con::ControlNorm, J, c, u)  # optional\n    J[1,:] .= u'/norm(u)\nend","category":"page"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"Importantly, note that the inheritance specifies the constraint applies only to individual controls.","category":"page"},{"location":"constraint_interface.html#Constraint-Types","page":"Constraint Interface","title":"Constraint Types","text":"","category":"section"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"The ConstraintType defines the whether the constraint is a function of just the  state, control, or both the state and control. This automatically defines the  RobotDynamics.FunctionInputs trait for the constraint.","category":"page"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"StageConstraint\nStateConstraint\nControlConstraint","category":"page"},{"location":"constraint_interface.html#TrajectoryOptimization.StageConstraint","page":"Constraint Interface","title":"TrajectoryOptimization.StageConstraint","text":"Only a function of states and controls at a single knotpoint\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.StateConstraint","page":"Constraint Interface","title":"TrajectoryOptimization.StateConstraint","text":"Only a function of states at a single knotpoint\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.ControlConstraint","page":"Constraint Interface","title":"TrajectoryOptimization.ControlConstraint","text":"Only a function of controls at a single knotpoint\n\n\n\n\n\n","category":"type"}]
}
