var documenterSearchIndex = {"docs":
[{"location":"constraint_api.html","page":"Constraints","title":"Constraints","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"constraint_api.html#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraint_api.html","page":"Constraints","title":"Constraints","text":"This page provides details about the various types in TrajectoryOptimization.jl for working with constraints, as well as the methods defined on those types. In general, a ConstraintList is used to define the constraints, and another AbstractConstraintSet is instantiated by a solver to hold the constraint values and Jacobians.","category":"page"},{"location":"constraint_api.html#Constraint-List","page":"Constraints","title":"Constraint List","text":"","category":"section"},{"location":"constraint_api.html","page":"Constraints","title":"Constraints","text":"A ConstraintList is used to define a trajectory optimization Problem and only holds basic information about the constraints included in the problem. Although it is a child of AbstractConstraintSet and supports indexing and iteration, it does not hold any information about constraint values or Jacobians.","category":"page"},{"location":"constraint_api.html","page":"Constraints","title":"Constraints","text":"ConstraintList\nadd_constraint!\nnum_constraints","category":"page"},{"location":"constraint_api.html#TrajectoryOptimization.ConstraintList","page":"Constraints","title":"TrajectoryOptimization.ConstraintList","text":"ConstraintList\n\nStores the set of constraints included in a trajectory optimization problem. Includes a list of both the constraint types AbstractConstraint as well as the knot points at which the constraint is applied. Each constraint is assumed to apply to a contiguous set of knot points.\n\nA ConstraintList supports iteration and indexing over the AbstractConstraints, and iteration of both the constraints and the indices of the knot points at which they apply via zip(cons::ConstraintList).\n\nConstraints are added via the add_constraint! method, which verifies that the constraint dimension is consistent with the state and control dimensions of the problem.\n\nThe total number of constraints at each knot point can be queried using the num_constraints method.\n\nThe constraint list can also be sorted to separate StageConstraints and CoupledConstraints via the sort! method.\n\nA constraint list can be queried if it has a DynamicsConstraint via has_dynamics_constraint(::ConstraintList).\n\nConstructor\n\nConstraintList(n::Int, m::Int, N::Int)\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.add_constraint!","page":"Constraints","title":"TrajectoryOptimization.add_constraint!","text":"add_constraint!(cons::ConstraintList, con::AbstractConstraint, inds::UnitRange, [idx])\n\nAdd constraint cons to ConstraintList cons for knot points given by inds.\n\nUse idx to determine the location of the constraint in the constraint list. idx=-1 (default) adds the constraint at the end of the list.\n\nExample\n\nHere is an example of adding a goal and control limit constraint for a cartpole swing-up.\n\n# Dimensions of our problem\nn,m,N = 4,1,51    # 51 knot points\n\n# Create our list of constraints\ncons = ConstraintList(n,m,N)\n\n# Create the goal constraint\nxf = [0,Ï€,0,0]\ngoalcon = GoalConstraint(xf)\nadd_constraint!(cons, goalcon, N)  # add to the last time step\n\n# Create control limits\nubnd = 3\nbnd = BoundConstraint(n,m, u_min=-ubnd, u_max=ubnd, idx=1)  # make it the first constraint\nadd_constraint!(cons, bnd, 1:N-1)  # add to all but the last time step\n\n# Indexing\ncons[1] === bnd                            # (true)\ncons[2] === goal                           # (true)\nallcons = [con for con in cons]\ncons_and_inds = [(con,ind) in zip(cons)]\ncons_and_inds[1] == (bnd,1:n-1)            # (true)\n\n\n\n\n\n","category":"function"},{"location":"constraint_api.html#TrajectoryOptimization.num_constraints","page":"Constraints","title":"TrajectoryOptimization.num_constraints","text":"num_constraints(::ConstraintList)\nnum_constraints(::Problem)\nnum_constraints(::TrajOptNLP)\n\nReturn a vector of length N constaining the total number of constraint values at each knot point.\n\n\n\n\n\nGet the number of constraint values at each time step\n\n\n\n\n\n","category":"function"},{"location":"constraint_api.html#Constraint-Sets","page":"Constraints","title":"Constraint Sets","text":"","category":"section"},{"location":"constraint_api.html","page":"Constraints","title":"Constraints","text":"A constraint set holding a list of ConVals is generally instantiated by a solver and holds the constraint definitions, as well as the associated constraint values, Jacobians, and other constraint-related information required by the solver.","category":"page"},{"location":"constraint_api.html","page":"Constraints","title":"Constraints","text":"AbstractConstraintSet","category":"page"},{"location":"constraint_api.html#TrajectoryOptimization.AbstractConstraintSet","page":"Constraints","title":"TrajectoryOptimization.AbstractConstraintSet","text":"AbstractConstraintSet\n\nStores constraint error and Jacobian values, correctly accounting for the error state if necessary.\n\nInterface\n\nget_convals(::AbstractConstraintSet)::Vector{<:ConVal} where the size of the Jacobians\n\nmatch the full state dimension\n\nget_errvals(::AbstractConstraintSet)::Vector{<:ConVal} where the size of the Jacobians\n\nmatch the error state dimension\n\nmust have field c_max::Vector{<:AbstractFloat} of length length(get_convals(conSet))\n\nMethods\n\nOnce the previous interface is defined, the following methods are defined\n\nBase.iterate: iterates over get_convals(conSet)\nBase.length: number of independent constraints\nevaluate!(conSet, Z::Traj): evaluate the constraints over the entire trajectory Z\njacobian!(conSet, Z::Traj): evaluate the constraint Jacobians over the entire trajectory Z\nerror_expansion!(conSet, model, G): evaluate the Jacobians for the error state using the\n\nstate error Jacobian `G`\n\nmax_violation(conSet): return the maximum constraint violation\nfindmax_violation(conSet): return details about the location of the maximum\n\nconstraint violation in the trajectory\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#Constraint-Value-type","page":"Constraints","title":"Constraint Value type","text":"","category":"section"},{"location":"constraint_api.html","page":"Constraints","title":"Constraints","text":"The AbstractConstraintValues type holds all the constraint values and Jacobians for a particular constraint, and supports different ways of storing those (either as individual matrices/vectors or as views into a large matrix/vector). This abstract type is meant to be implemented by the solver, but a reference implementation is provided, ConVal.","category":"page"},{"location":"constraint_api.html","page":"Constraints","title":"Constraints","text":"AbstractConstraintValues\nConVal","category":"page"},{"location":"constraint_api.html#TrajectoryOptimization.AbstractConstraintValues","page":"Constraints","title":"TrajectoryOptimization.AbstractConstraintValues","text":"AbstractConstraintValues{C<:AbstractConstraint}\n\nAn abstract type for working with and storing constraint values, such as current  constraint values, Jacobians, dual variables, penalty parameters, etc.  The information that is actually store, and the way it is stored, is up to the  child type. However, at a minimum, it should store the following fields:\n\ncon::AbstractConstraint: the actual constraint\nvals::AbstractVector{<:AbstractVector}: stores the constraint value for all time indices.\njac::AbstractMatrix{<:AbstractMatrix}: stores the constraint Jacobian for all time indices.\ninds::AbstractVector{Int}: stores the time step indices.\n\nThe first dimension of all of these data fields should be the same  (the number time indices).\n\nWith these fields, the following methods are implemented:\n\nevaluate!(::AbstractConstraintValues, ::AbstractTrajectory)\njacobian!(::AbstractConstraintValues, ::AbstractTrajectory)\nmax_violation(::AbstractConstraintValues)\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.ConVal","page":"Constraints","title":"TrajectoryOptimization.ConVal","text":"ConVal{C,V,M,W}\n\nHolds information about a constraint of type C. Allows for any type of vector (V) or matrix (M) storage for constraint values and Jacobians (allowing StaticArrays or views into a large, sparse matrix).\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#Implemented-Constraints","page":"Constraints","title":"Implemented Constraints","text":"","category":"section"},{"location":"constraint_api.html","page":"Constraints","title":"Constraints","text":"The following is a list of the constraints currently implemented in TrajectoryOptimization.jl. Please refer to the docstrings for the individual constraints on details on their constructors, since each constraint is unique, in general.","category":"page"},{"location":"constraint_api.html","page":"Constraints","title":"Constraints","text":"List of currently implemented constraints","category":"page"},{"location":"constraint_api.html","page":"Constraints","title":"Constraints","text":"GoalConstraint\nBoundConstraint\nLinearConstraint\nCircleConstraint\nSphereConstraint\nNormConstraint\nDynamicsConstraint\nIndexedConstraint","category":"page"},{"location":"constraint_api.html","page":"Constraints","title":"Constraints","text":"GoalConstraint\nBoundConstraint\nLinearConstraint\nCircleConstraint\nSphereConstraint\nNormConstraint\nDynamicsConstraint\nIndexedConstraint","category":"page"},{"location":"constraint_api.html#TrajectoryOptimization.GoalConstraint","page":"Constraints","title":"TrajectoryOptimization.GoalConstraint","text":"GoalConstraint{P,T}\n\nConstraint of the form x_g = a, where x_g can be only part of the state vector.\n\nConstructors:\n\nGoalConstraint(xf::AbstractVector)\nGoalConstraint(xf::AbstractVector, inds)\n\nwhere xf is an n-dimensional goal state. If inds is provided, only xf[inds] will be used.\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.BoundConstraint","page":"Constraints","title":"TrajectoryOptimization.BoundConstraint","text":"BoundConstraint{P,NM,T}\n\nLinear bound constraint on states and controls\n\nConstructors\n\nBoundConstraint(n, m; x_min, x_max, u_min, u_max)\n\nAny of the bounds can be Â±âˆž. The bound can also be specifed as a single scalar, which applies the bound to all state/controls.\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.LinearConstraint","page":"Constraints","title":"TrajectoryOptimization.LinearConstraint","text":"LinearConstraint{S,P,W,T}\n\nLinear constraint of the form Ay - b leq= 0 where y may be either the state or controls (but not a combination of both).\n\nConstructor: ```julia\n\nLinearConstraint{S,W}(n,m,A,b) ``whereW <: Union{State,Control}`.\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.CircleConstraint","page":"Constraints","title":"TrajectoryOptimization.CircleConstraint","text":"CircleConstraint{P,T}\n\nConstraint of the form (x - x_c)^2 + (y - y_c)^2 geq r^2 where x, y are given by x[xi],x[yi], (x_cy_c) is the center of the circle, and r is the radius.\n\nConstructor:\n\nCircleConstraint(n, xc::SVector{P}, yc::SVector{P}, radius::SVector{P}, xi=1, yi=2)\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.SphereConstraint","page":"Constraints","title":"TrajectoryOptimization.SphereConstraint","text":"SphereConstraint{P,T}\n\nConstraint of the form (x - x_c)^2 + (y - y_c)^2 + (z - z_c)^2 geq r^2 where x, y, z are given by x[xi],x[yi],x[zi], (x_cy_cz_c) is the center of the sphere, and r is the radius.\n\nConstructor:\n\nSphereConstraint(n, xc::SVector{P}, yc::SVector{P}, zc::SVector{P},\n\tradius::SVector{P}, xi=1, yi=2, zi=3)\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.NormConstraint","page":"Constraints","title":"TrajectoryOptimization.NormConstraint","text":"NormConstraint{S,D,T}\n\nConstraint of the form y_2 leq a where y is made up of elements from the state and/or control vectors. The can be equality constraint, e.g. y^T y - a^2 = 0, an inequality constraint, where y^T y - a^2 \\leq 0, or a second-order constraint.\n\nConstructor:\n\nNormConstraint(n, m, a, sense, [inds])\n\nwhere n is the number of states,     m is the number of controls,     a is the constant on the right-hand side of the equation,     sense is Inequality(), Equality(), or SecondOrderCone(), and     inds can be a UnitRange, AbstractVector{Int}, or either :state or :control\n\nExamples:\n\nNormConstraint(3, 2, 4, Equality(), :control)\n\ncreates a constraint equivalent to u^2 = 160 for a problem with 2 controls.\n\nNormConstraint(3, 2, 3, Inequality(), :state)\n\ncreates a constraint equivalent to x^2 leq 9 for a problem with 3 states.\n\nNormConstraint(3, 2, 5, SecondOrderCone(), :control)\n\ncreates a constraint equivalent to  x_2 leq 5.\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.DynamicsConstraint","page":"Constraints","title":"TrajectoryOptimization.DynamicsConstraint","text":"struct DynamicsConstraint{Q<:RobotDynamics.QuadratureRule, L<:RobotDynamics.AbstractModel, N, M, NM, T} <: TrajectoryOptimization.AbstractDynamicsConstraint\n\nAn equality constraint imposed by the discretized system dynamics. Links adjacent time steps. Supports both implicit and explicit integration methods. Can store values internally for more efficient computation of dynamics and dynamics Jacobians over the entire trajectory, particularly for explicit methods. These constraints are used in Direct solvers, where the dynamics are explicit stated as constraints in a more general optimization method.\n\nConstructors\n\nDynamicsConstraint{Q}(model::AbstractModel, N)\n\nwhere N is the number of knot points and Q<:QuadratureRule is the integration method.\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.IndexedConstraint","page":"Constraints","title":"TrajectoryOptimization.IndexedConstraint","text":"IndexedConstraint{C,N,M}\n\nCompute a constraint on an arbitrary portion of either the state or control, or both. Useful for dynamics augmentation. e.g. you are controlling two models, and have individual constraints on each. You can define constraints as if they applied to the individual model, and then wrap it in an IndexedConstraint to apply it to the appropriate portion of the concatenated state. Assumes the indexed state or control portion is contiguous.\n\nType params:\n\nS - Inequality or Equality\nW - ConstraintType\nP - Constraint length\nN,M - original state and control dimensions\nNM - N+M\nBx - location of the first element in the state index\nBu - location of the first element in the control index\nC - type of original constraint\n\nConstructors:\n\nIndexedConstraint(n, m, con)\nIndexedConstraint(n, m, con, ix::UnitRange, iu::UnitRange)\n\nwhere the arguments n and m are the state and control dimensions of the new dynamics. ix and iu are the indices into the state and control vectors. If left out, they are assumed to start at the beginning of the vector.\n\nNOTE: Only part of this functionality has been tested. Use with caution!\n\n\n\n\n\n","category":"type"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"rotations.html#Optimizing-Rotations","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"","category":"section"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"Optimization over the space of rotations is non-trivial due to the group structure  of 3D rotations. TrajectoryOptimization.jl provides methods for accounting for this group structure, both in the constraints and in the objective. We make the assumption that 3D rotation only show up in the state vector, and never in the control vector. TrajectoryOptimization.jl relies on the dynamics model to determine if the state vector contains rotations. See the  RobotDynamics.jl documentation for more details on defining models with rotations. From here, we assume that we are dealing with a model that inherits from RobotDynamics.LieGroupModel.","category":"page"},{"location":"rotations.html#Cost-Functions-(experimental)","page":"Optimizing Rotations","title":"Cost Functions (experimental)","text":"","category":"section"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"While normal quadratic cost functions can work with rotations (e.g. q_k^T Q q_k, where q_k is a quaternion, MRP, or RP), this distance metric isn't well-defined.  Since we often want to penalize the distance from a reference rotation  (such as a nominal or goal state), TrajectoryOptimization.jl provides a couple different methods for penalizing distance from a reference rotation. However, we've  discovered that the quaternion geodesic distance: ","category":"page"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"min 1 pm q_d^T q_k","category":"page"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"where q_d is the desired, or reference, quaternion, works the best. We've also  found that, while technically incorrect, a naive quadratic penalty can work quite well, especially when the difference between the rotations isn't significant. ","category":"page"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"The following cost functions are provided. Note that these methods should still be  considered experimental, and the interface made change in the future. If you encounter any issues using these functions, please submit an issue.","category":"page"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"DiagonalQuatCost\nQuatLQRCost\nErrorQuadratic","category":"page"},{"location":"rotations.html#TrajectoryOptimization.DiagonalQuatCost","page":"Optimizing Rotations","title":"TrajectoryOptimization.DiagonalQuatCost","text":"DiagonalQuatCost\n\nQuadratic cost function for states that includes a 3D rotation, that penalizes deviations      from a provided 3D rotation, represented as a Unit Quaternion.\n\nThe cost function penalizes geodesic distance between unit quaternions:\n\nfrac12 big( x^T Q x + u^T R u big) + q^T x + r^T u + c + w min 1 pm p_f^T p\n\nwhere p is the quaternion extracted from x (i.e. p = x[q_ind]), and p_f  is the reference quaternion. Q and R are assumed to be diagonal.\n\nWe've found this perform better than penalizing a quadratic on the quaternion error  state (ErrorQuadratic). This cost should still be considered experimental.\n\nConstructors\n\nDiagonalQuatCost(Q::Diagonal, R::Diagonal, q, r, c, w, q_ref, q_ind; terminal)\nDiagonalQuatCost(Q::Diagonal, R::Diagonal; q, r, c, w, q_ref, q_ind, terminal)\n\nwhere q_ref is the reference quaternion (provided as a SVector{4}), and      q_ind::SVector{4,Int} provides the indices of the quaternion in the state vector      (default = SA[4,5,6,7]). Note that Q and q are the size of the full state,      so Q.diag[q_ind] and q[qind] should typically be zero.\n\n\n\n\n\n","category":"type"},{"location":"rotations.html#TrajectoryOptimization.QuatLQRCost","page":"Optimizing Rotations","title":"TrajectoryOptimization.QuatLQRCost","text":"QuatLQRCost(Q, R, xf, [uf; w, quat_ind])\n\nDefines a cost function of the form:\n\nfrac12 big( (x - x_f)^T Q (x - x_f) + (u - u_f)^T R (u - u_f) big) + w min 1 pm q_f^T q\n\nwhere Q and R are diagonal, x_f is the goal state,  u_f is the reference control, and q_f, q are the quaternions, extracted from x using quat_ind, i.e. q = x[quat_ind].\n\nThe last term is the geodesic distance between quaternions. It's typically recommended that  Q.diag[quad_ind] == zeros(4).\n\nThis is just a convenience constructor for DiagonalQuatCost.\n\nExample\n\nFor a standard rigid body state vector x = [p; q; v; Ï‰], where q is a unit quaternion, we could define a cost function that penalizes the distance to the goal state xf.  We can create this cost function as follows:\n\nQ = Diagonal(SVector(RBState(fill(0.1,3), zeros(4), fill(0.1,3), fill(0.1,3))))\nR = Diagonal(@SVector fill(0.01, 6))\nxf = RBState([1,2,3], rand(UnitQuaternion), zeros(3), zeros(3))\nQuatLQRCost(Q,R,xf)\n\nWe can add a reference control and change the weight on the rotation error with the optional arguments:\n\nQuatLQRCost(Q,R,xf,uf, w=10.0)\n\nwhich is equivalent to\n\nQuatLQRCost(Q,R,xf,uf, w=10.0, quat_inds=4:7)\n\n\n\n\n\n","category":"function"},{"location":"rotations.html#TrajectoryOptimization.ErrorQuadratic","page":"Optimizing Rotations","title":"TrajectoryOptimization.ErrorQuadratic","text":"ErrorQuadratic{Rot,N,M}\n\nCost function of the form:\n\nfrac12 (x_k ominus x_d)^T Q_k (x_k ominus x_d)\n\nwhere x_k ominus x_d is the error state, computed using  RobotDynamics.state_diff.  This cost function isn't recommended: we've found that DiagonalQuatCost usually     peforms better and is much more computationally efficient.\n\n\n\n\n\n","category":"type"},{"location":"rotations.html#Cost-and-Constraint-Expansions","page":"Optimizing Rotations","title":"Cost and Constraint Expansions","text":"","category":"section"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"The key to performing optimization on Lie Groups such as rotations is to perform  the optimization on the tangent bundle, or simply the hyperplane tangent to the  group at the current iterate. Since the tangent space is Euclidean, we use  standard optimization methods such as Newton's method to find a step direction.  After we find a candidate step direction, we project back onto the group using  the exponential map (or any other \"retraction map\").  For rotations and unit quaternions, this means we  can either use the exponential map, or use the conversions between unit quaternions and MRPs or RPs (Rodrigues Parameters). Since most optimization methods require gradient or Hessian information, we need to correctly account for the mapping to the the tangent plane when computing derivatives.","category":"page"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"TrajectoryOptimization.jl handles this by first computing the derivatives as normal,  treating the state (naively) as a vector in Euclidean space. This means methods such  as ForwardDiff can be used without problem. These derivatives are then \"converted\"  to work on the error state. This conversion ends up being one or two extra matrix  multiplications with the so-called \"error-state Jacobian,\" which is a function of the rotation at the current iterate. ","category":"page"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"Therefore, computing the full derivative information is split into 2 steps:","category":"page"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"Compute the derivatives as normal.\nCompute the \"error expansion,\" using the result of step 1.","category":"page"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"For objectives this looks like:","category":"page"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"TrajectoryOptimization.state_diff_jacobian!(G, model, Z)\nTrajectoryOptimization.cost_expansion!(E0, obj, Z, [init, rezero])\nTrajectoryOptimization.error_expansion!(E, E0, model, Z, G)","category":"page"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"The corrected expansion is stored in E::QuadraticObjective. The first line computes the error-state Jacobians, storing them in G. The intermediate expansion is stored  in E0::QuadraticObjective. For models that do not have rotations, E === E0 and the last line is a no-op.","category":"page"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"For dynamics this looks very similar:","category":"page"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"TrajectoryOptimization.state_diff_jacobian!(G, model, Z)\nTrajectoryOptimization.dynamics_expansion!(::Type{Q}, D::DynamicsExpansion, model, Z)\nTrajectoryOptimization.error_expansion!(D::DynamicsExpansion, model, G)","category":"page"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"The first line can be omitted if it has already be computed for the current  trajectory Z::AbstractTrajectory.","category":"page"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"This functionality is still under development for constraints. Since augmented  Lagrangian methods incorporate the constraints into the objective, the error  expansion is computed on the entire cost, rather than computing an intermediate error expansion for the constraints, saving computation. If you need this  functionality, please submit an issue.","category":"page"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"The experimental interface is currently:","category":"page"},{"location":"rotations.html","page":"Optimizing Rotations","title":"Optimizing Rotations","text":"TrajectoryOptimization.jacobian!(conSet::AbstractConstraintSet, Z::AbstractTrajectory, [init])\nTrajectoryOptimization.error_expansion!(conSet::AbstractConstraintSet, model, G)","category":"page"},{"location":"constraints.html#constraint_section","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"","category":"section"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"Pages = [\"constraints.md\"]","category":"page"},{"location":"constraints.html#Creating-Constraint-Sets","page":"3. Creating Constraints","title":"Creating Constraint Sets","text":"","category":"section"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"The easiest way to set up the constraints for your problem is through the ConstraintList. This structure simply holds a vector of all the constraints in the trajectory optimization problem. The easiest way to start is to create an empty ConstraintList:","category":"page"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"cons = ConstraintList(n,m,N)","category":"page"},{"location":"constraints.html#Adding-Constraints","page":"3. Creating Constraints","title":"Adding Constraints","text":"","category":"section"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"You can add any constraint (the list of currently implemented constraints is given in the following section) to the constraint set using the add_constraint! method. For example, if we want to add control limits and an final goal constraint to our problem, we do this by creating a ConstraintList and subsequently adding the constraints:","category":"page"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"# Dimensions of our problem\nn,m,N = 4,1,51    # 51 knot points\n\n# Create our list of constraints\ncons = ConstraintList(n,m,N)\n\n# Create the goal constraint\nxf = [0,Ï€,0,0]\ngoalcon = GoalConstraint(xf)\nadd_constraint!(cons, goalcon, N)  # add to the last time step\n\n# Create control limits\nubnd = 3\nbnd = BoundConstraint(n,m, u_min=-ubnd, u_max=ubnd)\nadd_constraint!(cons, bnd, 1:N-1)  # add to all but the last time step","category":"page"},{"location":"constraints.html#Defined-Constraints","page":"3. Creating Constraints","title":"Defined Constraints","text":"","category":"section"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"The following constraints are currently defined. See their individual docstrings on details on how to construct them, since constraint constructors are, in general, unique to the constraint.","category":"page"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"GoalConstraint\nBoundConstraint\nCircleConstraint\nSphereConstraint\nNormConstraint\nIndexedConstraint","category":"page"},{"location":"constraints.html#Working-with-ConstraintList","page":"3. Creating Constraints","title":"Working with ConstraintList","text":"","category":"section"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"The ConstraintList type is useful type that provides some convenient methods for manipulating and working with the constraints in your trajectory optimization problem.","category":"page"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"It supports many of the operations that work on an AbstractVector, such as length, indexing (e.g. cons[1] or cons[end]), and iteration (e.g. [con for con in cons]).","category":"page"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"The time step indices can be retrieved via the inds field, e.g. cons.inds[1] returns the indices for the first constraint. You can also iterate over constraints and their time indices simultaneously using zip(::ConstraintList), e.g. [(length(con), length(inds)) for (con,inds) in zip(cons)]. ","category":"page"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"The num_constraints(::ConstraintList) returns a vector of length N with total number of constraint values per time step. Note that since each constraint is vector-valued, this is different than length(::ConstraintList). The total number of dual variables can be calculated using sum(num_constraints(cons)).","category":"page"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"The constraint list can also be sorted via sort!(::ConstraintList) to partition it into constraints that apply each time step (StageConstraint) and those that apply across two time steps (CoupledConstraint), such as dynamics constraints.","category":"page"},{"location":"constraints.html","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"To query if a constraint list contains a dynamics constraint, use has_dynamics_constraint(::ConstraintList).","category":"page"},{"location":"nlp.html","page":"Converting to an NLP","title":"Converting to an NLP","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"nlp.html#Converting-to-an-NLP","page":"Converting to an NLP","title":"Converting to an NLP","text":"","category":"section"},{"location":"nlp.html","page":"Converting to an NLP","title":"Converting to an NLP","text":"Pages = [\"nlp.md\"]","category":"page"},{"location":"nlp.html","page":"Converting to an NLP","title":"Converting to an NLP","text":"Trajectory optimization problems are really just nonlinear programs (NLPs). A handful of high-quality NLP solvers exist, such as Ipopt, Snopt, and KNITRO. TrajectoryOptimization provides an interface that allows methods that are amenable to use with a general-purpose NLP solver. In the NLP, the states and constraints at every knot point are concatenated into a single large vector of decision variables, and the cost hessian and constraint Jacobians are represented as large, sparse matrices.","category":"page"},{"location":"nlp.html#Important-Types","page":"Converting to an NLP","title":"Important Types","text":"","category":"section"},{"location":"nlp.html","page":"Converting to an NLP","title":"Converting to an NLP","text":"Below is the documentation for the types used to represent a trajectory optimization problem as an NLP:","category":"page"},{"location":"nlp.html","page":"Converting to an NLP","title":"Converting to an NLP","text":"NLPData\nNLPConstraintSet\nQuadraticViewCost\nViewKnotPoint\nTrajData\nNLPTraj","category":"page"},{"location":"nlp.html#TrajectoryOptimization.NLPData","page":"Converting to an NLP","title":"TrajectoryOptimization.NLPData","text":"Holds all the required data structures for evaluating a trajectory optimization problem as \tan NLP. It represents the cost gradient, Hessian, constraints, and constraint Jacobians \tas large, sparse arrays, as applicable.\n\nConstructors\n\nNLPData(G, g, zL, zU, D, d, Î»)\nNLPData(G, g, zL, zU, D, d, Î», v, r, c)\nNLPData(NN, P, [nD])  # suggested constructor\n\nwhere G and g are the cost function gradient and hessian of size (NN,NN) and (NN,), zL and zU are the lower and upper bounds on the NN primal variables, D and d are the constraint jacobian and violation of size (P,NN) and (P,), and v, r, c are the values, rows, and columns of the non-zero elements of the costraint Jacobian, all of length nD.\n\n\n\n\n\n","category":"type"},{"location":"nlp.html#TrajectoryOptimization.NLPConstraintSet","page":"Converting to an NLP","title":"TrajectoryOptimization.NLPConstraintSet","text":"NLPConstraintSet{T}\n\nConstraint set that updates views to the NLP constraint vector and Jacobian.\n\nThe views can be reset to new arrays using reset_views!(::NLPConstraintSet, ::NLPData)\n\n\n\n\n\n","category":"type"},{"location":"nlp.html#TrajectoryOptimization.QuadraticViewCost","page":"Converting to an NLP","title":"TrajectoryOptimization.QuadraticViewCost","text":"QuadraticViewCost{n,m,T}\n\nA quadratic cost that is a view into a large sparse matrix\n\n\n\n\n\n","category":"type"},{"location":"nlp.html#TrajectoryOptimization.ViewKnotPoint","page":"Converting to an NLP","title":"TrajectoryOptimization.ViewKnotPoint","text":"ViewKnotPoint{T,n,m}\n\nAn AbstractKnotPoint whose data is a view into the vector containing all primal variables in the trajectory optimization problem.\n\n\n\n\n\n","category":"type"},{"location":"nlp.html#TrajectoryOptimization.TrajData","page":"Converting to an NLP","title":"TrajectoryOptimization.TrajData","text":"TrajData{n,m,T}\n\nDescribes the partitioning of the vector of primal variables, where xinds[k] and uinds[k] give the states and controls at time step k, respectively. t is the vector of times and dt are the time step lengths for each time step.\n\n\n\n\n\n","category":"type"},{"location":"nlp.html#TrajectoryOptimization.NLPTraj","page":"Converting to an NLP","title":"TrajectoryOptimization.NLPTraj","text":"NLPTraj{n,m,T} <: AbstractTrajectory{n,m,T}\n\nA trajectory of states and controls, where the underlying data storage is a large vector.\n\nSupports indexing and iteration, where the elements are StaticKnotPoints.\n\n\n\n\n\n","category":"type"},{"location":"nlp.html#The-TrajOptNLP-type","page":"Converting to an NLP","title":"The TrajOptNLP type","text":"","category":"section"},{"location":"nlp.html","page":"Converting to an NLP","title":"Converting to an NLP","text":"The most important type is the TrajOptNLP, which is a single struct that has all the required methods to evaluate the trajectory optimization problem as an NLP.","category":"page"},{"location":"nlp.html","page":"Converting to an NLP","title":"Converting to an NLP","text":"TrajOptNLP","category":"page"},{"location":"nlp.html#TrajectoryOptimization.TrajOptNLP","page":"Converting to an NLP","title":"TrajectoryOptimization.TrajOptNLP","text":"TrajOptNLP{n,m,T}\n\nRepresents a trajectory optimization problem as a generic nonlinear program (NLP). Convenient for use with direct methods that manipulate the decision variables across all time steps as as a single vector (i.e. a \"batch\" formulation).\n\nConstructor\n\nTrajOptNLP(prob::Problem; remove_bounds, jac_type)\n\nIf remove_bounds = true, any constraints that can be expressed as simple upper and lower bounds on the primal variables (the states and controls) are removed from the ConstraintList and treated separately.\n\nOptions for jac_type\n\n:sparse: Use a SparseMatrixCSC to represent the constraint Jacobian.\n:vector: Use (v,r,c) tuples to represent the constraint Jacobian, where\n\nD[r[i],c[i]] = v[i] if D is the constraint Jacobian.\n\n\n\n\n\n","category":"type"},{"location":"nlp.html#Interface","page":"Converting to an NLP","title":"Interface","text":"","category":"section"},{"location":"nlp.html","page":"Converting to an NLP","title":"Converting to an NLP","text":"Use the following methods on a TrajOptNLP nlp. Unless otherwise noted, Z is a single vector of NN decision variables (where NN is the total number of states and controls across all knot points).","category":"page"},{"location":"nlp.html","page":"Converting to an NLP","title":"Converting to an NLP","text":"eval_f\ngrad_f!\nhess_f!\nhess_f_structure\neval_c!\njac_c!\njacobian_structure\nhess_L!","category":"page"},{"location":"nlp.html#TrajectoryOptimization.eval_f","page":"Converting to an NLP","title":"TrajectoryOptimization.eval_f","text":"eval_f(nlp::TrajOptNLP, Z)\n\nEvalate the cost function at Z.\n\n\n\n\n\n","category":"function"},{"location":"nlp.html#TrajectoryOptimization.grad_f!","page":"Converting to an NLP","title":"TrajectoryOptimization.grad_f!","text":"grad_f!(nlp::TrajOptNLP, Z, g)\n\nEvaluate the gradient of the cost function for the vector of decision variables Z, storing \tthe result in the vector g.\n\n\n\n\n\n","category":"function"},{"location":"nlp.html#TrajectoryOptimization.hess_f!","page":"Converting to an NLP","title":"TrajectoryOptimization.hess_f!","text":"hess_f!(nlp::TrajOptNLP, Z, G)\n\nEvaluate the hessian of the cost function for the vector of decision variables Z, \tstoring the result in G, a sparse matrix.\n\n\n\n\n\n","category":"function"},{"location":"nlp.html#TrajectoryOptimization.hess_f_structure","page":"Converting to an NLP","title":"TrajectoryOptimization.hess_f_structure","text":"hess_f_structure(nlp::TrajOptNLP)\n\nReturns a sparse matrix D of the same size as the constraint Jacobian, corresponding to the sparsity pattern of the constraint Jacobian. Additionally, D[i,j] is either zero or a unique index from 1 to nnz(D).\n\n\n\n\n\n","category":"function"},{"location":"nlp.html#TrajectoryOptimization.eval_c!","page":"Converting to an NLP","title":"TrajectoryOptimization.eval_c!","text":"eval_c!(nlp::TrajOptNLP, Z, c)\n\nEvaluate the constraints at Z, storing the result in c.\n\n\n\n\n\n","category":"function"},{"location":"nlp.html#TrajectoryOptimization.jac_c!","page":"Converting to an NLP","title":"TrajectoryOptimization.jac_c!","text":"jac_c!(nlp::TrajOptNLP, Z, C)\n\nEvaluate the constraint Jacobian at Z, storing the result in C.\n\n\n\n\n\n","category":"function"},{"location":"nlp.html#TrajectoryOptimization.jacobian_structure","page":"Converting to an NLP","title":"TrajectoryOptimization.jacobian_structure","text":"jacobian_structure(nlp::TrajOptNLP)\n\nReturns a sparse matrix D of the same size as the constraint Jacobian, corresponding to the sparsity pattern of the constraint Jacobian. Additionally, D[i,j] is either zero or a unique index from 1 to nnz(D).\n\n\n\n\n\n","category":"function"},{"location":"nlp.html#TrajectoryOptimization.hess_L!","page":"Converting to an NLP","title":"TrajectoryOptimization.hess_L!","text":"hess_L(nlp::TrajOptNLP, Z, Î», G)\n\nCalculate the Hessian of the Lagrangian G, with the vector of current primal variables Z and dual variables Î».\n\n\n\n\n\n","category":"function"},{"location":"nlp.html","page":"Converting to an NLP","title":"Converting to an NLP","text":"The following methods are useful to getting important information that is typically required by an NLP solver","category":"page"},{"location":"nlp.html","page":"Converting to an NLP","title":"Converting to an NLP","text":"primal_bounds!\nconstraint_type","category":"page"},{"location":"nlp.html#TrajectoryOptimization.primal_bounds!","page":"Converting to an NLP","title":"TrajectoryOptimization.primal_bounds!","text":"primal_bounds!(zL, zU, con::AbstractConstraint)\n\nSet the lower zL and upper zU bounds on the primal variables imposed by the constraint con. Return whether or not the vectors zL or zU could be modified by con (i.e. if the constraint con is a bound constraint).\n\n\n\n\n\nprimal_bounds!(zL, zU, cons::ConstraintList; remove=true)\n\nGet the lower and upper bounds on the primal variables imposed by the constraints in cons, where zL and zU are vectors of length NN, where NN is the total number of primal variables in the problem. Returns the modified lower bound zL and upper bound zU.\n\nIf any of the bound constraints are redundant, the strictest bound is returned.\n\nIf remove = true, these constraints will be removed from cons.\n\n\n\n\n\nprimal_bounds!(nlp::TrajOptNLP, zL, zU)\n\nGet the lower and upper bounds on the primal variables.\n\n\n\n\n\n","category":"function"},{"location":"nlp.html#TrajectoryOptimization.constraint_type","page":"Converting to an NLP","title":"TrajectoryOptimization.constraint_type","text":"constraint_type(nlp::TrajOptNLP)\n\nBuild a vector of length IE = num_constraints(nlp) where IE[i] is the type of constraint for constraint i.\n\nLegend:\n\n0 -> Inequality\n1 -> Equality\n\n\n\n\n\n","category":"function"},{"location":"nlp.html#MathOptInterface","page":"Converting to an NLP","title":"MathOptInterface","text":"","category":"section"},{"location":"nlp.html","page":"Converting to an NLP","title":"Converting to an NLP","text":"The TrajOptNLP can be used to set up an MathOptInterface.AbstractOptimizer to solve the trajectory optimization problem. For example if we want to use Ipopt and have already set up our TrajOptNLP, we can solve it using build_MOI!(nlp, optimizer):","category":"page"},{"location":"nlp.html","page":"Converting to an NLP","title":"Converting to an NLP","text":"using Ipopt\nusing MathOptInterface\nnlp = TrajOptNLP(...)  # assume this is already set up\noptimizer = Ipopt.Optimizer()\nTrajectoryOptimization.build_MOI!(nlp, optimizer)\nMathOptInterface.optimize!(optimizer)","category":"page"},{"location":"model.html","page":"1. Setting Up a Dynamics Model","title":"1. Setting Up a Dynamics Model","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"model.html#.-Setting-Up-a-Dynamics-Model","page":"1. Setting Up a Dynamics Model","title":"1. Setting Up a Dynamics Model","text":"","category":"section"},{"location":"model.html","page":"1. Setting Up a Dynamics Model","title":"1. Setting Up a Dynamics Model","text":"TrajectoryOptimization relies on the interface defined by RobotDynamics.jl to define the forced dynamics required to solve the problem. Please refer to the documentation for more details on setting up and defining models. We present a simple example here.","category":"page"},{"location":"model.html","page":"1. Setting Up a Dynamics Model","title":"1. Setting Up a Dynamics Model","text":"Assume we want to find an optimal trajectory for the canonical cartpole system. We can either import the existing model defined in RobotZoo.jl or use RobotDynamics.jl to define our own. Defining our own model is pretty straight-forward:","category":"page"},{"location":"model.html","page":"1. Setting Up a Dynamics Model","title":"1. Setting Up a Dynamics Model","text":"struct Cartpole{T} <: AbstractModel\n    mc::T\n    mp::T\n    l::T\n    g::T\nend\n\nCartpole() = Cartpole(1.0, 0.2, 0.5, 9.81)\n\nfunction dynamics(model::Cartpole, x, u)\n    mc = model.mc  # mass of the cart in kg (10)\n    mp = model.mp   # mass of the pole (point mass at the end) in kg\n    l = model.l   # length of the pole in m\n    g = model.g  # gravity m/s^2\n\n    q  = x[ SA[1,2] ]  # SA[...] creates a StaticArray.\n    qd = x[ SA[3,4] ]\n\n    s = sin(q[2])\n    c = cos(q[2])\n\n    H = @SMatrix [mc+mp mp*l*c; mp*l*c mp*l^2]\n    C = @SMatrix [0 -mp*qd[2]*l*s; 0 0]\n    G = @SVector [0, mp*g*l*s]\n    B = @SVector [1, 0]\n\n    qdd = -H\\(C*qd + G - B*u[1])\n    return [qd; qdd]\nend\n\nRobotDynamics.state_dim(::Cartpole) = 4\nRobotDynamics.control_dim(::Cartpole) = 1","category":"page"},{"location":"model.html","page":"1. Setting Up a Dynamics Model","title":"1. Setting Up a Dynamics Model","text":"with our dynamics model defined, we are ready to start setting up the optimization problem.","category":"page"},{"location":"model.html","page":"1. Setting Up a Dynamics Model","title":"1. Setting Up a Dynamics Model","text":"tip: Tip\nFor best performance, use StaticArrays.jl, which offers loop-unrolling and allocation-free methods for  small to medium-sized matrices and vectors.","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"creating_problems.html#problem_section","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"","category":"section"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"The Problem contains all of the information needed to solve a trajectory optimization problem. At a minimum, this is the model, objective, and initial condition. A Problem is passed to a solver, which extracts needed information, and may or may or not modify its internal representation of the problem in order to solve it (e.g. the Augmented Lagrangian solver combines the constraints and objective into a single Augmented Lagrangian objective.)","category":"page"},{"location":"creating_problems.html#Creating-a-Problem","page":"4. Setting up a Problem","title":"Creating a Problem","text":"","category":"section"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"Let's say we're trying to solve the following trajectory optimization problem:","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"beginaligned\n  min_x_0Nu_0N-1 quad  (x_N-x_f)^T Q_f (x_N-x_f) + dt sum_k=0^N-1 (x_k-x_f)^T Q (x_k - x_f) + u^T R u  \n  textrmst            quad  x_k+1 = f(x_k u_k) \n                                  u_k leq 3 \n                                  x_N = x_f \nendaligned","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"We'll quickly set up the dynamics, objective, and constraints. See previous sections for more details on how to do this.","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"using TrajectoryOptimization\nusing RobotZoo: Cartpole\nusing StaticArrays, LinearAlgebra\n\n# Dynamics and Constants\nmodel = Cartpole()\nn,m = size(model)\nN = 101   # number of knot points\ntf = 5.0  # final time\nx0 = @SVector [0, 0, 0, 0.]  # initial state\nxf = @SVector [0, Ï€, 0, 0.]  # goal state (i.e. swing up)\n\n# Objective\nQ = Diagonal(@SVector fill(1e-2,n))\nR = Diagonal(@SVector fill(1e-1,m))\nQf = Diagonal(@SVector fill(100.,n))\nobj = LQRObjective(Q, R, Qf, xf, N)\n\n# Constraints\nconSet = ConstraintList(n,m,N)\nbnd = BoundConstraint(n,m, u_min=-3.0, u_max=3.0)\ngoal = GoalConstraint(xf)\nadd_constraint!(conSet, bnd, 1:N-1)\nadd_constraint!(conSet, goal, N:N)","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"The following method is the easiest way to set up a trajectory optimization problem:","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"prob = Problem(model, obj, xf, tf, constraints=conSet, x0=x0, integration=RK3)","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"where the keyword arguments are, of course, optional.","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"This constructor has the following arguments:","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"(required) model::AbstractModel - dynamics model\n(required) obj::AbstractObjective - objective function\n(required) xf::AbstractVector - goal state (this will be made optional in the near future)\n(required) tf::AbstractFloat - final time\n(optional) constraints::ConstraintSet - constraint set. Default is no constraints.\n(optional) x0::AbstractVector - Initial state. Default is the zero vector.\n(optional) N::Int - number of knot points. Default is given by length of objective.\n(optional) dt::AbstractFloat - Time step length. Can be either a scalar or a vector of length N. Default is calculated using tf and N.\n(optional) integration::Type{<:QuadratureRule} - Quadrature rule for discretizing the dynamics. Default is given by TrajectoryOptimization.DEFAULT_Q.\n(optional) X0 - Initial guess for state trajectory. Can either be a matrix of size (n,N) or a vector of length N of n-dimensional vectors.\n(optional) U0 - Initial guess for control trajectory. Can either be a matrix of size (m,N) or a vector of length N-1 of n-dimensional vectors.","category":"page"},{"location":"creating_problems.html#Initialization","page":"4. Setting up a Problem","title":"Initialization","text":"","category":"section"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"A good initialization is critical to getting good results for nonlinear optimization problems. TrajectoryOptimization.jl current supports initialization of the state and control trajectories. Initialization of dual variables (i.e. Lagrange multipliers) is not yet support but will be included in the near future. The state and control trajectories can be initialized directly in the constructor using the X0 and U0 keyword arguments described above, or using the following methods:","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"initial_states!(prob, X0)\ninitial_controls!(prob, U0)","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"where, again, these can either be matrices or vectors of vectors of the appropriate size. It should be noted that these methods work on either Problems or instances of AbstractSolver.","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"Alternatively, the problem can be initialized with both the state and control trajectories simultaneously by passing in a vector of KnotPoints, described in the next sections.","category":"page"},{"location":"creating_problems.html#KnotPoint-Type","page":"4. Setting up a Problem","title":"KnotPoint Type","text":"","category":"section"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"Internally, TrajectoryOptimization.jl stores the state and controls at each time step as a concatenated vector inside the KnotPoint type defined by RobotDynamics.jl. In addition to storing the state and control, the KnotPoint type also stores the time and time step length for the current knot point. See the documention in RobotDynamics for more information.","category":"page"},{"location":"creating_problems.html#Traj-Type","page":"4. Setting up a Problem","title":"Traj Type","text":"","category":"section"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"The Traj type is simply a vector of KnotPoints. However, it provides a few helpful methods for constructing and working vectors of KnotPoints, which effectively describe a discrete-time state-control trajectory.","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"Traj","category":"page"},{"location":"creating_problems.html#RobotDynamics.Traj","page":"4. Setting up a Problem","title":"RobotDynamics.Traj","text":"Traj{n,m,T,KP}\n\nA vector of AbstractKnotPoints of type KP with state dimension n, control dimension m, and value type T\n\nSupports iteration and indexing.\n\nConstructors\n\nTraj(n, m, dt, N, equal=false)\nTraj(x, u, dt, N, equal=false)\nTraj(X, U, dt, t)\nTraj(X, U, dt)\n\n\n\n\n\n","category":"type"},{"location":"creating_problems.html#Other-Methods","page":"4. Setting up a Problem","title":"Other Methods","text":"","category":"section"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"You can extract the state and control trajectories separately with the following methods:","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"states(Z::Traj)\ncontrols(Z::Traj)","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"Note that these methods also work on Problem. ","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"The states, control, and time trajectories can be set independently with the following methods:","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"set_states!(Z::Traj, X::Vector{<:AbstractVector})\nset_controls!(Z::Traj, U::Vector{<:AbstractVector})\nset_times!(Z::Traj, t::Vector)","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"To initialize a problem with a given Traj type, you can use","category":"page"},{"location":"creating_problems.html","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"initial_trajectory!(::Problem, Z::AbstractTrajectory)","category":"page"},{"location":"problem.html","page":"Problem","title":"Problem","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"problem.html#Problem","page":"Problem","title":"Problem","text":"","category":"section"},{"location":"problem.html","page":"Problem","title":"Problem","text":"Pages = [\"problem.md\"]","category":"page"},{"location":"problem.html#Definition","page":"Problem","title":"Definition","text":"","category":"section"},{"location":"problem.html","page":"Problem","title":"Problem","text":"Problem","category":"page"},{"location":"problem.html#TrajectoryOptimization.Problem","page":"Problem","title":"TrajectoryOptimization.Problem","text":"struct Problem{Q<:RobotDynamics.QuadratureRule, T<:AbstractFloat}\n\nTrajectory Optimization Problem. Contains the full definition of a trajectory optimization problem, including:\n\ndynamics model (Model)\nobjective (Objective)\nconstraints (ConstraintSet)\ninitial and final states\nPrimal variables (state and control trajectories)\nDiscretization information: knot points (N), time step (dt), and total time (tf)\n\nConstructors:\n\nProblem(model, obj, constraints, x0, xf, Z, N, tf) # defaults to RK3 integration\nProblem{Q}(model, obj, constraints, x0, xf, Z, N, tf) where Q<:QuadratureRule\nProblem(model, obj, xf, tf; x0, constraints, N, X0, U0, dt, integration)\nProblem{Q}(prob::Problem)  # change integration\n\nwhere Z is a trajectory (Vector of KnotPoints)\n\nArguments\n\nmodel: Dynamics model. Can be either Discrete or Continuous\nobj: Objective\nX0: Initial state trajectory. If omitted it will be initialized with NaNs, to be later overwritten by the solver.\nU0: Initial control trajectory. If omitted it will be initialized with zeros.\nx0: Initial state. Defaults to zeros.\nxf: Final state. Defaults to zeros.\ndt: Time step\ntf: Final time. Set to zero to specify a time penalized problem.\nN: Number of knot points. Defaults to 51, unless specified by dt and tf.\nintegration: One of the defined integration types to discretize the continuous dynamics model.\n\nBoth X0 and U0 can be either a Matrix or a Vector{Vector}, but must be the same. At least 2 of dt, tf, and N need to be specified (or just 1 of dt and tf).\n\n\n\n\n\n","category":"type"},{"location":"problem.html#Methods","page":"Problem","title":"Methods","text":"","category":"section"},{"location":"problem.html#Getters","page":"Problem","title":"Getters","text":"","category":"section"},{"location":"problem.html","page":"Problem","title":"Problem","text":"cost(::Problem)\nstates(::Problem)\ncontrols(::Problem)\nBase.size(::Problem)\nnum_constraints(::Problem)\nget_constraints\nget_model\nget_trajectory\nget_initial_state\nRobotDynamics.get_times(::Problem)\nintegration(::Problem)\nis_constrained","category":"page"},{"location":"problem.html#TrajectoryOptimization.cost-Tuple{Problem}","page":"Problem","title":"TrajectoryOptimization.cost","text":"cost(::Problem)\n\nCompute the cost for the current trajectory\n\n\n\n\n\n","category":"method"},{"location":"problem.html#RobotDynamics.states-Tuple{Problem}","page":"Problem","title":"RobotDynamics.states","text":"states(::Problem)\n\nGet the state trajectory.\n\n\n\n\n\n","category":"method"},{"location":"problem.html#RobotDynamics.controls-Tuple{Problem}","page":"Problem","title":"RobotDynamics.controls","text":"controls(::Problem)\n\nGet the control trajectory\n\n\n\n\n\n","category":"method"},{"location":"problem.html#Base.size-Tuple{Problem}","page":"Problem","title":"Base.size","text":"size(prob::Problem) -> Tuple{Any,Any,Int64}\n\n\nGet number of states, controls, and knot points\n\n\n\n\n\n","category":"method"},{"location":"problem.html#TrajectoryOptimization.num_constraints-Tuple{Problem}","page":"Problem","title":"TrajectoryOptimization.num_constraints","text":"Get the number of constraint values at each time step\n\n\n\n\n\n","category":"method"},{"location":"problem.html#TrajectoryOptimization.get_constraints","page":"Problem","title":"TrajectoryOptimization.get_constraints","text":"Get problem constraints. Returns AbstractConstraintSet.\n\n\n\n\n\n","category":"function"},{"location":"problem.html#TrajectoryOptimization.get_model","page":"Problem","title":"TrajectoryOptimization.get_model","text":"Get the dynamics model. Returns RobotDynamics.AbstractModel.\n\n\n\n\n\n","category":"function"},{"location":"problem.html#TrajectoryOptimization.get_trajectory","page":"Problem","title":"TrajectoryOptimization.get_trajectory","text":"Get the trajectory. Returns an RobotDynamics.AbstractTrajectory\n\n\n\n\n\n","category":"function"},{"location":"problem.html#TrajectoryOptimization.get_initial_state","page":"Problem","title":"TrajectoryOptimization.get_initial_state","text":"Get the in initial state. Returns an AbstractVector.\n\n\n\n\n\n","category":"function"},{"location":"problem.html#RobotDynamics.get_times-Tuple{Problem}","page":"Problem","title":"RobotDynamics.get_times","text":"get_times(::Problem)\n\nGet the times for all the knot points in the problem.\n\n\n\n\n\n","category":"method"},{"location":"problem.html#TrajectoryOptimization.integration-Tuple{Problem}","page":"Problem","title":"TrajectoryOptimization.integration","text":"integration(::Problem)\nintegration(::DynamicsConstraint)\n\nGet the integration rule\n\n\n\n\n\n","category":"method"},{"location":"problem.html#TrajectoryOptimization.is_constrained","page":"Problem","title":"TrajectoryOptimization.is_constrained","text":"Determines if the problem is constrained.\n\n\n\n\n\n","category":"function"},{"location":"problem.html#Setters","page":"Problem","title":"Setters","text":"","category":"section"},{"location":"problem.html","page":"Problem","title":"Problem","text":"initial_controls!(::Problem, X0::Vector{<:AbstractVector})\ninitial_states!(::Problem, U0::Vector{<:AbstractVector})\ninitial_trajectory!\nset_initial_state!(::Problem, x0::AbstractVector)\nset_initial_time!(::Problem, t0::Real)\nset_goal_state!\nchange_integration","category":"page"},{"location":"problem.html#TrajectoryOptimization.initial_controls!-Tuple{Problem,Array{#s23,1} where #s23<:(AbstractArray{T,1} where T)}","page":"Problem","title":"TrajectoryOptimization.initial_controls!","text":"initial_controls!(::Problem, U0::Vector{<:AbstractVector})\ninitial_controls!(::Problem, U0::AbstractMatrx)\n\nCopy the control trajectory\n\n\n\n\n\n","category":"method"},{"location":"problem.html#TrajectoryOptimization.initial_states!-Tuple{Problem,Array{#s23,1} where #s23<:(AbstractArray{T,1} where T)}","page":"Problem","title":"TrajectoryOptimization.initial_states!","text":"initial_states!(::Problem, X0::Vector{<:AbstractVector})\ninitial_states!(::Problem, X0::AbstractMatrix)\n\nCopy the state trajectory\n\n\n\n\n\n","category":"method"},{"location":"problem.html#TrajectoryOptimization.initial_trajectory!","page":"Problem","title":"TrajectoryOptimization.initial_trajectory!","text":"initial_trajectory!(prob::Problem, Z)\n\nCopy the trajectory\n\n\n\n\n\n","category":"function"},{"location":"problem.html#TrajectoryOptimization.set_initial_state!-Tuple{Problem,AbstractArray{T,1} where T}","page":"Problem","title":"TrajectoryOptimization.set_initial_state!","text":"set_initial_state!(prob::Problem, x0::AbstractVector)\n\nSet the initial state in prob to x0\n\n\n\n\n\n","category":"method"},{"location":"problem.html#TrajectoryOptimization.set_initial_time!-Tuple{Problem,Real}","page":"Problem","title":"TrajectoryOptimization.set_initial_time!","text":"set_initial_time!(prob, t0)\n\nSet the initial time of the optimization problem, shifting the time of all points in the trajectory. Returns the updated final time.\n\n\n\n\n\n","category":"method"},{"location":"problem.html#TrajectoryOptimization.set_goal_state!","page":"Problem","title":"TrajectoryOptimization.set_goal_state!","text":"set_goal_state!(prob::Problem, xf::AbstractVector; objective=true, constraint=true)\n\nChange the goal state. If the appropriate flags are true, it will also modify a  GoalConstraint and the objective, assuming it's an LQRObjective.\n\n\n\n\n\n","category":"function"},{"location":"problem.html#TrajectoryOptimization.change_integration","page":"Problem","title":"TrajectoryOptimization.change_integration","text":"change_integration(prob::Problem, Q<:QuadratureRule)\n\nChange dynamics integration for the problem. Returns a new problem.\n\n\n\n\n\n","category":"function"},{"location":"problem.html#Other","page":"Problem","title":"Other","text":"","category":"section"},{"location":"problem.html","page":"Problem","title":"Problem","text":"rollout!\nBase.copy(::Problem)","category":"page"},{"location":"problem.html#RobotDynamics.rollout!","page":"Problem","title":"RobotDynamics.rollout!","text":"rollout!(::Problem)\n\nSimulate the dynamics forward from the initial condition x0 using the controls in the trajectory Z. If a problem is passed in, Z = prob.Z, model = prob.model, and x0 = prob.x0.\n\n\n\n\n\n","category":"function"},{"location":"problem.html#Base.copy-Tuple{Problem}","page":"Problem","title":"Base.copy","text":"Copy the problem\n\n\n\n\n\n","category":"method"},{"location":"costfunction_interface.html","page":"Cost Function Interface","title":"Cost Function Interface","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"costfunction_interface.html#Cost-Function-Interface","page":"Cost Function Interface","title":"Cost Function Interface","text":"","category":"section"},{"location":"costfunction_interface.html","page":"Cost Function Interface","title":"Cost Function Interface","text":"All cost functions are required to define the following methods","category":"page"},{"location":"costfunction_interface.html","page":"Cost Function Interface","title":"Cost Function Interface","text":"n = state_dim(cost)\nm = control_dim(cost)\nJ = stage_cost(cost, x, u)\nJ = stage_cost(cost, xN)\ngradient!(E::QuadraticCostFunction, cost, x, u)\ngradient!(E::QuadraticCostFunction, cost, xN)\nhessian!(E::QuadraticCostFunction, cost, x, u)\nhessian!(E::QuadraticCostFunction, cost, xN)","category":"page"},{"location":"costfunction_interface.html","page":"Cost Function Interface","title":"Cost Function Interface","text":"and inherit from CostFunction. Note the it is good practice to use the method defined on the terminal state internal to the method defined for both the state and control, i.e. gradient!(E, cost, x, u) should call gradient!(E, cost, xN). They then inherit the following methods defined on knot points:","category":"page"},{"location":"costfunction_interface.html","page":"Cost Function Interface","title":"Cost Function Interface","text":"stage_cost(::CostFunction, ::KnotPoint)\ngradient!(::QuadraticCostFunction, ::CostFunction, ::AbstractKnotPoint)\nhessian!(::QuadraticCostFunction, ::CostFunction, ::AbstractKnotPoint)","category":"page"},{"location":"costfunction_interface.html#Objective-Interface","page":"Cost Function Interface","title":"Objective Interface","text":"","category":"section"},{"location":"costfunction_interface.html","page":"Cost Function Interface","title":"Cost Function Interface","text":"The objective interface is very simple. After inheriting from AbstractObjective, define the following methods:","category":"page"},{"location":"costfunction_interface.html","page":"Cost Function Interface","title":"Cost Function Interface","text":"Base.length(::NewObjective)       # number of knot points\nget_J(::NewObjective)             # return vector of costs at each knot point\ncost!(::NewObjective, Z::Traj)    # calculate the cost at each knot point and store in get_J(::NewSolver)\ncost_expansion!(E::CostExpansion, obj::NewObjective, Z::Traj)","category":"page"},{"location":"costfunction_interface.html","page":"Cost Function Interface","title":"Cost Function Interface","text":"And inherits the single method","category":"page"},{"location":"costfunction_interface.html","page":"Cost Function Interface","title":"Cost Function Interface","text":"cost(::NewObjective, Z::Traj)","category":"page"},{"location":"costfunction_interface.html","page":"Cost Function Interface","title":"Cost Function Interface","text":"that simply returns the summed cost.","category":"page"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"There are a couple of detailed example notebooks in the examples folder.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"For more examples, see the problems included in ALTRO.jl and run as part of it's test suite.","category":"page"},{"location":"dynamics.html","page":"Evaluating the Dynamics and Jacobians","title":"Evaluating the Dynamics and Jacobians","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"dynamics.html#Evaluating-the-Dynamics-and-Jacobians","page":"Evaluating the Dynamics and Jacobians","title":"Evaluating the Dynamics and Jacobians","text":"","category":"section"},{"location":"dynamics.html","page":"Evaluating the Dynamics and Jacobians","title":"Evaluating the Dynamics and Jacobians","text":"The dynamics are all specified by the model::AbstractModel using  RobotDynamics.jl. We state here the methods that are implemented both in RobotDynamics and  TrajectoryOptimization for working with dynamics and dynamics expansions.","category":"page"},{"location":"dynamics.html","page":"Evaluating the Dynamics and Jacobians","title":"Evaluating the Dynamics and Jacobians","text":"To integrate the dynamics forward in time along an entire trajectory, use","category":"page"},{"location":"dynamics.html","page":"Evaluating the Dynamics and Jacobians","title":"Evaluating the Dynamics and Jacobians","text":"rollout!(::Type{Q}, model, Z)","category":"page"},{"location":"dynamics.html","page":"Evaluating the Dynamics and Jacobians","title":"Evaluating the Dynamics and Jacobians","text":"where Q <: RobotDynamics.QuadratureRule is any of the integration methods defined  in RobotDynamics.","category":"page"},{"location":"dynamics.html","page":"Evaluating the Dynamics and Jacobians","title":"Evaluating the Dynamics and Jacobians","text":"To evaluate the dynamics Jacobians, you can use RobotDynamcis.DynamicsJacobian","category":"page"},{"location":"dynamics.html","page":"Evaluating the Dynamics and Jacobians","title":"Evaluating the Dynamics and Jacobians","text":"jac = RobotDynamics.DynamicsJacobian(model)\nRobotDynamics.jacobian!(jac, model, z)                      # continuous Jacobian\nRobotDynamics.discrete_jacobian!(::Type{Q}, jac, model, z)  # discrete Jacobian","category":"page"},{"location":"dynamics.html","page":"Evaluating the Dynamics and Jacobians","title":"Evaluating the Dynamics and Jacobians","text":"which is a lightweight type that inherits from AbstractArray. You can extract  the Jacobians with respect to the state and control by accessing the fields A and  B, respectively, or using the more generic getter functions","category":"page"},{"location":"dynamics.html","page":"Evaluating the Dynamics and Jacobians","title":"Evaluating the Dynamics and Jacobians","text":"RobotDynamics.get_A\nRobotDynamics.get_B","category":"page"},{"location":"dynamics.html","page":"Evaluating the Dynamics and Jacobians","title":"Evaluating the Dynamics and Jacobians","text":"Alternatively, TrajectoryOptimization.jl provides the more heavyweight  DynamicsExpansion which can account for rotational states in a LieGroupModel  (for more information see Optimizing Rotations or RobotDynamics documentation).","category":"page"},{"location":"dynamics.html","page":"Evaluating the Dynamics and Jacobians","title":"Evaluating the Dynamics and Jacobians","text":"DynamicsExpansion","category":"page"},{"location":"dynamics.html#TrajectoryOptimization.DynamicsExpansion","page":"Evaluating the Dynamics and Jacobians","title":"TrajectoryOptimization.DynamicsExpansion","text":"DynamicsExpansion{T,N,NÌ„,M}\n\nStores the dynamics expansion for a single time instance.  For a LieGroupModel, it will provide access to both the state and state error Jacobians.\n\nConstructors\n\nDynamicsExpansion{T}(n0, n, m)\nDynamicsExpansion{T}(n, m)\n\nwhere n0 is the size of the full state, and n is the size of the error state.\n\nMethods\n\nTo evaluate the dynamics Jacobians, use\n\ndynamics_expansion!(::Type{Q}, D::DynamicsExpansion, model, Z)\n\nTo compute the Jacobians for the error state, use\n\nerror_expansion!(D::DynamicsExpansion, model, G)\n\nwhere G is a vector of error-state Jacobians. These can be computed using RobotDynamics.state_diff_jacobian(G, model, Z).\n\nExtracting Jacobians\n\nThe Jacobians should be extracted using\n\nfdx, fdu = error_expansion(D::DynamicsExpansion, model)\n\nThis method will provide the error state Jacobians for LieGroupModels, and  \tthe normal Jacobian otherwise. Both fdx and fdu are a SizedMatrix.\n\n\n\n\n\n","category":"type"},{"location":"dynamics.html","page":"Evaluating the Dynamics and Jacobians","title":"Evaluating the Dynamics and Jacobians","text":"To evaluate the dynamics Jacobians for an entire trajectory, in the most general case, use","category":"page"},{"location":"dynamics.html","page":"Evaluating the Dynamics and Jacobians","title":"Evaluating the Dynamics and Jacobians","text":"# Setup and initialization\nN = 11    # number of knot points\ndt = 0.1  # time step (sec)\nn0,m = size(model)\nn = state_diff_size(model)\nG = [SizedMatrix{n0,n}(zeros(n0,n)) for k = 1:N]\nD = [DynamicsExpansion{Float64}(n0,n,m)] for k = 1:N]\nZ = Traj(n0,n,dt,N)\nRobotDynamics.set_state!(Z[1], rand(model)[1])\nset_controls!(Z, rand(m,N-1))\nrollout!(RK4, model, Z)\n\nTrajectoryOptimization.state_diff_jacobian!(G, model, Z)\nTrajectoryOptimization.dynamics_expansion!(::Type{Q}, D::DynamicsExpansion, model, Z)\nTrajectoryOptimization.error_expansion!(D::DynamicsExpansion, model, G)","category":"page"},{"location":"dynamics.html","page":"Evaluating the Dynamics and Jacobians","title":"Evaluating the Dynamics and Jacobians","text":"For models that are not a LieGroupModel, the 3rd to last and last lines are not necessary.","category":"page"},{"location":"cost_api.html","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"cost_api.html#Cost-Functions-and-Objectives","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"","category":"section"},{"location":"cost_api.html","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"This page details the functions related to building and evaluating cost functions and objectives.","category":"page"},{"location":"cost_api.html#Cost-Functions","page":"Cost Functions and Objectives","title":"Cost Functions","text":"","category":"section"},{"location":"cost_api.html","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"CostFunction\nQuadraticCostFunction\nDiagonalCost\nQuadraticCost\nLQRCost\nis_diag\nis_blockdiag\ninvert!","category":"page"},{"location":"cost_api.html#TrajectoryOptimization.CostFunction","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.CostFunction","text":"Abstract type that represents a scalar-valued function that accepts a state and control at a single knot point.\n\n\n\n\n\n","category":"type"},{"location":"cost_api.html#TrajectoryOptimization.QuadraticCostFunction","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.QuadraticCostFunction","text":"An abstract type that represents any CostFunction of the form\n\nfrac12 x^T Q x + frac12 u^T R u + u^T H x + q^T x + r^T u + c\n\nThese types all support the following methods\n\nis_diag\nis_blockdiag\ninvert!\n\nAs well as standard addition.\n\n\n\n\n\n","category":"type"},{"location":"cost_api.html#TrajectoryOptimization.DiagonalCost","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.DiagonalCost","text":"DiagonalCost{n,m,T}\n\nCost function of the form\n\nfrac12 x^T Q x + frac12 u^T R u + q^T x + r^T u + c\n\nwhere Q and R are positive semi-definite and positive definite diagonal matrices, respectively, and x is n-dimensional and u is m-dimensional.\n\nConstructors\n\nDiagonalCost(Qd, Rd, q, r, c; kwargs...)\nDiagonalCost(Q, R, q, r, c; kwargs...)\nDiagonalCost(Qd, Rd; [q, r, c, kwargs...])\nDiagonalCost(Q, R; [q, r, c, kwargs...])\n\nwhere Qd and Rd are the diagonal vectors, and Q and R are matrices.\n\nAny optional or omitted values will be set to zero(s). The keyword arguments are\n\nterminal - A Bool specifying if the cost function is terminal cost or not.\nchecks - A Bool specifying if Q and R will be checked for the required definiteness.\n\n\n\n\n\n","category":"type"},{"location":"cost_api.html#TrajectoryOptimization.QuadraticCost","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.QuadraticCost","text":"QuadraticCost{n,m,T,TQ,TR}\n\nCost function of the form\n\nfrac12 x^T Q x + frac12 u^T R u + u^T H x + q^T x + r^T u + c\n\nwhere R must be positive definite, Q and Q_f must be positive semidefinite.\n\nThe type parameters TQ and TR specify the type of Q and R.\n\nConstructor\n\nQuadraticCost(Q, R, H, q, r, c; kwargs...)\nQuadraticCost(Q, R; H, q, r, c, kwargs...)\n\nAny optional or omitted values will be set to zero(s). The keyword arguments are\n\nterminal - A Bool specifying if the cost function is terminal cost or not.\nchecks - A Bool specifying if Q and R will be checked for the required definiteness.\n\n\n\n\n\n","category":"type"},{"location":"cost_api.html#TrajectoryOptimization.LQRCost","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.LQRCost","text":"LQRCost(Q, R, xf, [uf; kwargs...])\n\nConvenience constructor for a QuadraticCostFunction of the form:\n\nfrac12 (x-x_f)^T Q (x-xf) + frac12 (u-u_f)^T R (u-u_f)\n\nIf Q and R are diagonal, the output will be a DiagonalCost, otherwise it will be a QuadraticCost.\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.is_diag","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.is_diag","text":"is_diag(::QuadraticCostFunction)\n\nDetermines if the hessian of a quadratic cost function is strictly diagonal.\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.is_blockdiag","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.is_blockdiag","text":"is_diag(::QuadraticCostFunction)\n\nDetermines if the hessian of a quadratic cost function is block diagonal (i.e. norm(H) = 0).\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.invert!","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.invert!","text":"invert!(Ginv, cost::QuadraticCostFunction)\n\nInvert the hessian of the cost function, storing the result in Ginv. Performs the inversion     efficiently, depending on the structure of the Hessian (diagonal or block diagonal).\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#Adding-Cost-Functions","page":"Cost Functions and Objectives","title":"Adding Cost Functions","text":"","category":"section"},{"location":"cost_api.html","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"Right now, TrajectoryOptimization supports addition of QuadraticCosts, but extensions to general cost function addition should be straightforward, as long as the cost function all have the same state and control dimensions.","category":"page"},{"location":"cost_api.html","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"Adding quadratic cost functions:","category":"page"},{"location":"cost_api.html","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"n,m = 4,5\nQ1 = Diagonal(@SVector [1.0, 1.0, 1.0, 1.0, 0.0])\nR1 = Diagonal(@SVector [1.0, 0.0, 0.0, 0.0, 0.0, 0.0])\nQ2 = Diagonal(@SVector [1.0, 1.0, 1.0, 1.0, 2.0])\nR2 = Diagonal(@SVector [0.0, 1.0, 1.0, 1.0, 1.0, 1.0])\ncost1 = QuadraticCost(Q1, R1)\ncost2 = QuadraticCost(Q2, R2)\ncost3 = cost1 + cost2\n# cost3 is equivalent to QuadraticCost(Q1+Q2, R1+R2)","category":"page"},{"location":"cost_api.html#Objectives","page":"Cost Functions and Objectives","title":"Objectives","text":"","category":"section"},{"location":"cost_api.html","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"Objective\nLQRObjective\nTrackingObjective\nget_J\ndgrad\ndhess\nnorm_grad\nupdate_trajectory!","category":"page"},{"location":"cost_api.html#TrajectoryOptimization.Objective","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.Objective","text":"struct Objective{C} <: TrajectoryOptimization.AbstractObjective\n\nObjective: stores stage cost(s) and terminal cost functions\n\nConstructors:\n\nObjective(cost, N)\nObjective(cost, cost_term, N)\nObjective(costs::Vector{<:CostFunction}, cost_term)\nObjective(costs::Vector{<:CostFunction})\n\n\n\n\n\n","category":"type"},{"location":"cost_api.html#TrajectoryOptimization.LQRObjective","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.LQRObjective","text":"LQRObjective(Q, R, Qf, xf, N)\n\nCreate an objective of the form (x_N - x_f)^T Q_f (x_N - x_f) + sum_k=0^N-1 (x_k-x_f)^T Q (x_k-x_f) + u_k^T R u_k\n\nWhere eltype(obj) <: DiagonalCost if Q, R, and Qf are     Union{Diagonal{<:Any,<:StaticVector}}, <:StaticVector}\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.TrackingObjective","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.TrackingObjective","text":"TrackingObjective(Q, R, Z; [Qf])\n\nGenerate a quadratic objective that tracks the reference trajectory specified by Z.\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.get_J","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.get_J","text":"Get the vector of costs at each knot point. sum(get_J(obj)) is equal to the cost\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.dgrad","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.dgrad","text":"dgrad(E::QuadraticExpansion, dZ::Traj)\n\nCalculate the derivative of the cost in the direction of dZ, where E is the current quadratic expansion of the cost.\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.dhess","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.dhess","text":"dhess(E::QuadraticCost, dZ::Traj)\n\nCalculate the scalar 0.5dZ'GdZ where G is the hessian of cost\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.norm_grad","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.norm_grad","text":"norm_grad(E::QuadraticExpansion, p=2)\n\nNorm of the cost gradient\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.update_trajectory!","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.update_trajectory!","text":"update_trajectory!(obj, Z, [start=1])\n\nFor use with a tracking-style trajectory (see TrackingObjective). Update the costs to track the new trajectory Z. The start parameter specifies the  index of reference trajectory that should be used as the starting point of the reference  tracked by the objective. This is useful when a single, long time-horizon trajectory is given but the optimization only tracks a portion of the reference at each solve (e.g. MPC).\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#Evaluating-the-Cost","page":"Cost Functions and Objectives","title":"Evaluating the Cost","text":"","category":"section"},{"location":"cost_api.html","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"cost\nstage_cost\ngradient!\nhessian!\ncost_gradient!\ncost_hessian!\ncost_expansion!","category":"page"},{"location":"cost_api.html#TrajectoryOptimization.cost","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.cost","text":"cost(obj::Objective, Z::Traj)\ncost(obj::Objective, dyn_con::DynamicsConstraint{Q}, Z::Traj)\n\nEvaluate the cost for a trajectory. If a dynamics constraint is given,     use the appropriate integration rule, if defined.\n\n\n\n\n\ncost(::Problem)\n\nCompute the cost for the current trajectory\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.stage_cost","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.stage_cost","text":"stage_cost(costfun::CostFunction, x, u)\nstage_cost(costfun::CostFunction, x)\n\nCalculate the scalar cost using costfun given state x and control u. If only the state is provided, it is assumed it is a terminal cost.\n\n\n\n\n\nstage_cost(cost::CostFunction, z::AbstractKnotPoint)\n\nEvaluate the cost at a knot point, and automatically handle terminal knot point, multiplying by dt as necessary.\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.gradient!","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.gradient!","text":"gradient!(E::QuadraticCostFunction, costfun::CostFunction, z::AbstractKnotPoint, [cache])\n\nEvaluate the gradient of the cost function costfun at state x and control u, storing     the result in E.q and E.r. Return a true if the gradient is constant, and false     otherwise.\n\nIf is_terminal(z) is true, it will only calculate the gradientwith respect to the terminal state.\n\nThe optional cache argument provides an optional method to pass in extra memory to facilitate computation of cost expansion. It is vector of length 4, with the following entries: [grad, hess, grad_term, hess_term], where grad and hess are the caches  for gradients and Hessians repectively, and the []_term entries are the caches for the terminal cost function.\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.hessian!","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.hessian!","text":"hessian!(E, costfun::CostFunction, z::AbstractKnotPoint, [cache])\n\nEvaluate the hessian of the cost function costfun at knotpoint z.     the result in E.Q, E.R, and E.H. Return a true if the hessian is constant, and false     otherwise.\n\nIf is_terminal(z) is true, it will only calculate the Hessian with respect to the terminal state.\n\nThe optional cache argument provides an optional method to pass in extra memory to facilitate computation of cost expansion. It is vector of length 4, with the following entries: [grad, hess, grad_term, hess_term], where grad and hess are the caches  for gradients and Hessians repectively, and the []_term entries are the caches for the terminal cost function.\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.cost_gradient!","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.cost_gradient!","text":"cost_gradient!(E::Objective, obj::Objective, Z, init)\n\nEvaluate the cost gradient along the entire tracjectory Z, storing the result in E.\n\nIf init == true, all gradients will be evaluated, even if they are constant.\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.cost_hessian!","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.cost_hessian!","text":"cost_hessian!(E::Objective, obj::Objective, Z, init)\n\nEvaluate the cost hessian along the entire tracjectory Z, storing the result in E.\n\nIf init == true, all hessian will be evaluated, even if they are constant. If false, they will only be evaluated if they are not constant.\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.cost_expansion!","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.cost_expansion!","text":"cost_expansion!(E::Objective, obj::Objective, Z, [init, rezero])\n\nEvaluate the 2nd order Taylor expansion of the objective obj along the trajectory Z, storing the result in E.\n\nIf init == false, the expansions will only be evaluated if they are not constant.\n\nIf rezero == true, all expansions will be multiplied by zero before taking the expansion.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TrajectoryOptimization.jl-Documentation","page":"Introduction","title":"TrajectoryOptimization.jl Documentation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Documentation for TrajectoryOptimization.jl","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Pages = [\"index.md\"]","category":"page"},{"location":"index.html#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This package facilitates the definition and evaluation of trajectory optimization problems. Importantly, this package should be considered more of a modeling framework than an optimization solver, similar to Convex.jl. While general trajectory optimization problems are nonconvex, primarily due to the presence of nonlinear equality constraints imposed by the dynamics, they exhibit a unique structure that allows purpose-built solvers such as Altro.jl to gain significant computational savings over the use of more generalized NLP solvers such as SNOPT and Ipopt.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This package deals with trajectory optimization problems of the form,","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"beginaligned\n  min_x_0Nu_0N-1 quad  ell_f(x_N) + sum_k=0^N-1 ell_k(x_k u_k dt) \n  textrmst            quad  x_k+1 = f(x_k u_k) \n                                  g_k(x_ku_k) leq 0 \n                                  h_k(x_ku_k) = 0\nendaligned","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Key features include:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Easy and intuitive interface for setting up trajectory optimization problems\nSupport for general, per-timestep constraints\nSupport for Second-Order Cone constraints \nForwardDiff for fast auto-differentiation of dynamics, cost functions, and constraints\nEfficient methods for evaluating the trajectory optimization problem as a general NLP, so that it can be passed off to NLP solvers such as Ipopt or SNOPT via MathOptInterface.jl.","category":"page"},{"location":"index.html#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"TrajectoryOptimization.jl can be installed via the Julia package manager. Within the Julia REPL:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"] # activate the package manager\n(v1.5) pkg> add TrajectoryOptimization","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"A specific version can be specified using","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(v1.5) pkg> add TrajectoryOptimization@0.4.1","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Or you can check out the master branch with","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(v1.5) pkg> add TrajectoryOptimization#master","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Lastly, if you want to clone the repo into your .julia/dev/ directory for development, you can use","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(v1.5) pkg> dev TrajectoryOptimization","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This will automatically add all package dependencies (see Project.toml). If you want to explicitly use any of these dependencies (such as RobotDynamics.jl),  you'll need to individually add those packages to your environment via the package manager.","category":"page"},{"location":"costfunctions.html#objective_section","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"","category":"section"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Pages = [\"costfunctions.md\"]","category":"page"},{"location":"costfunctions.html#Overview","page":"2. Setting up an Objective","title":"Overview","text":"","category":"section"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"All trajectory optimization problems require a cost function at each stage of the trajectory. Cost functions must be scalar-valued. We assume general cost functions of the form,","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"ell_f(x_N) + sum_k=1^N-1 ell_k(x_ku_k) dt","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"It is very important to note that ell_k(x_ku_k) is ONLY a function of x_k and u_k, i.e. no coupling across time-steps is permitted. This is a requirement for Differential Dynamic Programming methods such as iLQR, but could be relaxed for methods that parameterize both states and controls, such as DIRCOL. In general, any coupling between adjacent time-steps can be resolved by augmenting the state and defining the appropriate dynamics (this is the method we use to solve minimum time problems).","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"In general, trajectory optimization will take a second order Taylor series approximation of the cost function, resulting in a quadratic cost function of the form","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"x_N^T Q_f x_N + q_f^T x_N + sum_k=1^N-1 x_k^T Q_k x_k + q_k^T x_k + u_k^T R_k u_k + r_k^T u_k + u_k^T H_k x_k","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"This type of quadratic cost is typical for trajectory optimization problems, especially when Q is positive semi-definite and R is positive definite, which is strictly convex. These problems behave well and reduce the computational requirements of taking second-order Taylor series expansions of the cost at each iteration.","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"In TrajectoryOptimization.jl we differentiate between the entire objective and the cost functions at each time step. We use Objective to describe the function that is being minimized, which typically consists of a sum of cost functions, with potentially some additional terms (as is the case with augmented Lagrangian objectives). Describing the Objective as a sum of individual functions allows the solvers to more efficiently compute the gradient and Hessian of the entire cost, which is block-diagonal given the Markovianity of the problem.","category":"page"},{"location":"costfunctions.html#Cost-functions","page":"2. Setting up an Objective","title":"Cost functions","text":"","category":"section"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"While TrajectoryOptimization allows for general nonlinear cost function in principle, currently only quadratic cost functions are implemented (implementing nonlinear cost functions is a great way to contribute!). All cost functions inherit from the general CostFunction type.","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Since quadratic costs are the most standard cost function they excellent place to start. Let's assume we are creating an LQR tracking cost of the form","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"(x_N - x_f)^T Q_f (x_N - x_f) + sum_k=1^N-1 (x_k - x_f)^T Q (x_k - x_f) + u_k^T R u_k","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"for the simple cartpole with the goal of doing a swing-up. To do this we have very convenient method LQRCost.","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"using LinearAlgebra, StaticArrays\nn,m = 4,1\nQ = Diagonal(@SVector fill(0.1,n))\nR = Diagonal(@SVector fill(0.1,m))\nQf = Diagonal(@SVector fill(1000,n))\nxf = @SVector [0,Ï€,0,0]\ncostfun = LQRCost(Q,R,xf)\ncostfun_term = LQRCost(Qf,R*0,xf,terminal=true)","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"tip: Tip\nIt is HIGHLY recommended to specify any special structure, such as Diagonal, especially since these matrices are almost always diagonal. See Julia's built-in LinearAlgebra module for more specialized matrix types.","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"This constructor actually does a simple conversion to turn our cost function into either the generic QuadraticCost or a DiagonalCost. We could do this ourselves:","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"H = @SMatrix zeros(m,n)\nq = -Q*xf\nr = @SVector zeros(m)\nc = xf'Q*xf/2\nqf = -Qf*xf\ncf = xf'Qf*xf/2\ncostfun      = QuadraticCost(Q, R, H, q, r, c)\ncostfun_term = QuadraticCost(Qf, R*0, H, qf, r*0, cf)","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"The QuadraticCost constructor also supports keyword arguments and one that allows for only Q,q and c.:","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"costfun = QuadraticCost(Q, R, q=q, c=c)","category":"page"},{"location":"costfunctions.html#Objective","page":"2. Setting up an Objective","title":"Objective","text":"","category":"section"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Once we have defined the cost function, we can create an objective for our problem by simply copying over all time steps (except for the terminal).","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"# Create an objective from a single cost function\nN = 51\nobj = Objective(costfun, costfun_term, N)","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"There's also a convenient constructor that skips all the previous steps and builds the objective directly, seeLQRObjective","category":"page"},{"location":"costfunctions.html","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"obj = LQRObjective(Q, R, Qf, xf, N)","category":"page"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"constraint_interface.html#Constraint-Interface","page":"Constraint Interface","title":"Constraint Interface","text":"","category":"section"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"All constraints inherit from AbstractConstraint.","category":"page"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"AbstractConstraint","category":"page"},{"location":"constraint_interface.html#TrajectoryOptimization.AbstractConstraint","page":"Constraint Interface","title":"TrajectoryOptimization.AbstractConstraint","text":"AbstractConstraint\n\nAbstract vector-valued constraint for a trajectory optimization problem. May be either inequality or equality (specified by sense(::AbstractConstraint)::ConstraintSense), and be function of single or adjacent knotpoints.\n\nInterface: Any constraint type must implement the following interface:\n\nn = state_dim(::MyCon)\nm = control_dim(::MyCon)\np = Base.length(::MyCon)\nsense(::MyCon)::ConstraintSense\nc = evaluate(::MyCon, args...)\njacobian!(âˆ‡c, ::MyCon, args...)\n\nAll constraints are categorized into the following type tree:\n\n                        AbstractConstraint\n                        â†™                â†˜\n           StageConstraint               CoupledConstraint\n            â†™        â†˜                       â†™           â†˜\nStageConstraint ControlConstraint CoupledStateConstraint CoupledControlConstraint\n\nThe state and control dimensions (where applicable) can be queried using state_dim(::AbstractConstraint) and control_dim(::AbstractConstraint). The dimensions of a constraint can be verified using check_dims. The width of the constraint Jacobian is given by get_inds or widths.\n\nThe number of constraint values associated with the constraint (length of the constraint vector) is given with length(::AbstractConstraint).\n\nEvaluation methods\n\nRefer to the doc strings for the following methods for more information on the required signatures.\n\nevaluate\njacobian!\nâˆ‡jacobian!\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#Constraint-Sense","page":"Constraint Interface","title":"Constraint Sense","text":"","category":"section"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"TrajectoryOptimization.jl assumes equality constraints are of the form g(x) = 0,  and that all other constraints are constrained to lie with a specified cone. This  is referred to as the ConstraintSense. The following are currently implemented:","category":"page"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"ConstraintSense\nEquality\nNegativeOrthant\nSecondOrderCone","category":"page"},{"location":"constraint_interface.html#TrajectoryOptimization.ConstraintSense","page":"Constraint Interface","title":"TrajectoryOptimization.ConstraintSense","text":"\" Specifies whether the constraint is an equality or inequality constraint. Valid subtypes are Equality, Inequality âŸº NegativeOrthant, and SecondOrderCone.\n\nThe sense of a constraint can be queried using sense(::AbstractConstraint)\n\nIf sense(con) <: Conic (i.e. not Equality), then the following operations are supported:\n\nBase.in(::Conic, x::StaticVector). i.e. x âˆˆ cone\nprojection(::Conic, x::StaticVector)\nâˆ‡projection(::Conic, J, x::StaticVector)\nâˆ‡Â²projection(::Conic, J, x::StaticVector, b::StaticVector)\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.Equality","page":"Constraint Interface","title":"TrajectoryOptimization.Equality","text":"Equality constraints of the form `g(x) = 0. Type singleton, so it is created with Equality().\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.NegativeOrthant","page":"Constraint Interface","title":"TrajectoryOptimization.NegativeOrthant","text":"Inequality constraints of the form h(x) leq 0. Type singleton, so it is created with Inequality().  Equivalent to NegativeOrthant.\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.SecondOrderCone","page":"Constraint Interface","title":"TrajectoryOptimization.SecondOrderCone","text":"The second-order cone is defined as  x leq t where x and t are both part of the cone. TrajectoryOptimization assumes the scalar part t is  the last element in the vector.\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#Evaluating-Constraints","page":"Constraint Interface","title":"Evaluating Constraints","text":"","category":"section"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"The following methods are used to evaluate a constraint:","category":"page"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"evaluate\nevaluate!\njacobian!\nâˆ‡jacobian!","category":"page"},{"location":"constraint_interface.html#TrajectoryOptimization.evaluate","page":"Constraint Interface","title":"TrajectoryOptimization.evaluate","text":"Return the constraint value\n\n\n\n\n\nevaluate(con::AbstractConstraint, z)       # stage constraint\nevaluate(con::AbstractConstraint, z1, z2)  # coupled constraint\n\nEvaluate the constraint con at knot point z. By default, this method will attempt to call\n\nevaluate(con, x)\n\nif con is a StateConstraint,\n\nevaluate(con, u)\n\nif con is a ControlConstraint, or\n\nevaluate(con, x, u)\n\nif con is a StageConstraint. If con is a CoupledConstraint the constraint should define\n\nevaluate(con, z1, z2)\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.evaluate!","page":"Constraint Interface","title":"TrajectoryOptimization.evaluate!","text":"evaluate!(vals, con::AbstractConstraint, Z, [inds])\n\nEvaluate constraints for entire trajectory. This is the most general method used to evaluate constraints along the trajectory Z, and should be the one used in other functions. The inds argument determines at which knot points the constraint is evaluated.\n\nIf con is a StageConstraint, this will call evaluate(con, z) by default, or evaluate(con, z1, z2) if con is a CoupledConstraint.\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#RobotDynamics.jacobian!","page":"Constraint Interface","title":"RobotDynamics.jacobian!","text":"jacobian!(âˆ‡f, model, z::AbstractKnotPoint, [cache])\n\nCompute the n Ã— (n + m) Jacobian âˆ‡f of the continuous-time dynamics. Only accepts an AbstractKnotPoint as input in order to avoid potential allocations associated with concatenation.\n\nThis method can use either ForwardDiff or FiniteDiff, based on the result of  RobotDynamics.diffmethod(model). When using FiniteDiff, the cache should be  passed in for best performance. The cache can be generated using either of the  following:\n\nRobotDynamics.gen_cache(model)\nFiniteDiff.JacobianCache(model)\n\n\n\n\n\njacobian!(âˆ‡c, con::AbstractConstraint, Z, [inds, is_const])\n\nEvaluate constraints for entire trajectory. This is the most general method used to evaluate constraints along the trajectory Z, and should be the one used in other functions. The inds argument determines at which knot points the constraint is evaluated. The optional is_const argument is a BitArray of the same size as âˆ‡c, and captures  the output of jacobian!, which should return a Boolean specifying if the Jacobian is constant or not.\n\nThe values are stored in âˆ‡c, which should be a matrix of matrices. If con is a StageConstraint, size(âˆ‡c,2) = 1, and size(âˆ‡c,2) = 2 if con is a CoupledConstraint.\n\nIf con is a StageConstraint, this will call jacobian!(âˆ‡c, con, z) by default, or jacobian!(âˆ‡c, con, z1, z2, i) if con is a CoupledConstraint.\n\n\n\n\n\njacobian!(âˆ‡c, con::AbstractConstraint, z, i=1)       # stage constraint\njacobian!(âˆ‡c, con::AbstractConstraint, z1, z2, i=1)  # coupled constraint\n\nEvaluate the constraint con at knot point z. By default, this method will attempt to call\n\njacobian!(âˆ‡c, con, x)\n\nif con is a StateConstraint,\n\njacobian!(âˆ‡c, con, u)\n\nif con is a ControlConstraint, or\n\njacobian!(âˆ‡c, con, x, u)\n\nif con is a StageConstraint. If con is a CoupledConstraint the constraint should define\n\njacobian!(âˆ‡c, con, z, i)\n\nwhere i determines which Jacobian should be evaluated. E.g. if i = 1, the Jacobian with respect to the first knot point's stage and controls is calculated.\n\nAutomatic Differentiation\n\nIf con is a StateConstraint or ControlConstraint then this method is automatically defined using ForwardDiff.\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.âˆ‡jacobian!","page":"Constraint Interface","title":"TrajectoryOptimization.âˆ‡jacobian!","text":"âˆ‡jacobian!(G, con::AbstractConstraint, Z, Î», inds, is_const, init)\nâˆ‡jacobian!(G, con::AbstractConstraint, Z::AbstractKnotPoint, Î»::AbstractVector)\n\nEvaluate the second-order expansion of the constraint con along the trajectory Z after multiplying by the lagrange multiplier Î». The optional is_const argument is a BitArray of the same size as âˆ‡c, and captures  the output of jacobian!, which should return a Boolean specifying if the Jacobian is constant or not. The init flag will force re-calculation of constant Jacobians when true.\n\nThe method for each constraint should calculate the Jacobian of the vector-Jacobian product,     and therefore should be of size n Ã— n if the input dimension is n.\n\nImportantly, this method should ADD and not overwrite the contents of G, since this term is dependent upon all the constraints acting at that time step.\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#Methods","page":"Constraint Interface","title":"Methods","text":"","category":"section"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"The following methods are defined for all AbstractConstraints","category":"page"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"state_dim\ncontrol_dim\nsense\nwidths\nupper_bound\nlower_bound\nis_bound\ncheck_dims\nget_inds","category":"page"},{"location":"constraint_interface.html#RobotDynamics.state_dim","page":"Constraint Interface","title":"RobotDynamics.state_dim","text":"Dimension of the state vector\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#RobotDynamics.control_dim","page":"Constraint Interface","title":"RobotDynamics.control_dim","text":"Dimension of the control vector\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.sense","page":"Constraint Interface","title":"TrajectoryOptimization.sense","text":"Get constraint sense (Inequality vs Equality)\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.widths","page":"Constraint Interface","title":"TrajectoryOptimization.widths","text":"widths(::AbstractConstraint)\nwidths(::AbstractConstraint, n, m)\n\nReturn a tuple of the widths of the Jacobians for a constraint. If n and m are not passed in, they are assumed to be consistent with those returned by state_dim and control_dim.\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.upper_bound","page":"Constraint Interface","title":"TrajectoryOptimization.upper_bound","text":"Upper bound of the constraint, as a vector, which is 0 for all constraints (except bound constraints)\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.lower_bound","page":"Constraint Interface","title":"TrajectoryOptimization.lower_bound","text":"Upper bound of the constraint, as a vector, which is 0 equality and -Inf for inequality (except bound constraints)\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.is_bound","page":"Constraint Interface","title":"TrajectoryOptimization.is_bound","text":"Is the constraint a bound constraint or not\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.check_dims","page":"Constraint Interface","title":"TrajectoryOptimization.check_dims","text":"Check whether the constraint is consistent with the specified state and control dimensions\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.get_inds","page":"Constraint Interface","title":"TrajectoryOptimization.get_inds","text":"get_inds(con::AbstractConstraint)\n\nGet the indices of the joint state-control vector that are used to calculate the constraint. If the constraint depends on more than one time step, the indices start from the beginning of the first one.\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#Adding-a-New-Constraint","page":"Constraint Interface","title":"Adding a New Constraint","text":"","category":"section"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"See interface description in documentation for AbstractConstraint. The interface allows for a lot of flexibility, but let's do a simple example. Let's say we have a 2-norm constraint on the controls at each time step, e.g. u leq a. We can do this with just a few lines of code:","category":"page"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"struct ControlNorm{T} <: ControlConstraint\n\tm::Int\n\tval::T\n\tfunction ControlNorm(m::Int, val::T) where T\n\t\t@assert val â‰¥ 0 \"Value must be greater than or equal to zero\"\n\t\tnew{T}(m,val,sense,inds)\n\tend\nend\ncontrol_dim(con::ControlNorm) = con.m\nsense(::ControlNorm) = Inequality()\nBase.length(::ControlNorm) = 1\nevaluate(con::ControlNorm, u::SVector) = SA[norm(u) - con.a] # needs to be a vector output\njacobian(con::ControlNorm, u::SVector) = u'/norm(u)  # optional","category":"page"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"Importantly, note that the inheritance specifies the constraint applies only to individual controls.","category":"page"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"Let's say the bound a varied by time-step. We could handle this easily by instead defining the methods operating on the entire trajectory:","category":"page"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"struct ControlNorm2{T} <: ControlConstraint\n\tm::Int\n\tval::Vector{T}\n\tfunction ControlNorm2(m::Int, val::T) where T\n\t\t@assert val â‰¥ 0 \"Value must be greater than or equal to zero\"\n\t\tnew{T}(m,val,sense,inds)\n\tend\nend\ncontrol_dim(con::ControlNorm2) = con.m\nsense(::ControlNorm2) = Inequality()\nBase.length(::ControlNorm2) = 1\nfunction evaluate!(vals, con::ControlNorm2, Z::AbstractTrajectory, inds=1:length(Z))\n\tfor (i,k) in enumerate(inds)\n\t\tu = control(Z[k])\n\t\tvals[i] = SA[norm(u) - con.a[i]]\n\tend\nend\nfunction jacobian!(âˆ‡c, con::ControlNorm2, Z::AbstractTrajectory, inds=1:length(Z),\n\t\tis_const = BitArray(undef, size(âˆ‡c)))\n\tfor (i,k) in enumerate(inds)\n\t\t\tu = control(Z[k])\n\t\t\tâˆ‡c[i] = u'/norm(u)\n\t\t\tis_const[i] = false\n\tend\nend","category":"page"},{"location":"constraint_interface.html#Constraint-Types","page":"Constraint Interface","title":"Constraint Types","text":"","category":"section"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"The ConstraintType defines the \"bandedness\" of the constraint, or the number of adjacent state or constraint values needed to calculate the constraint.","category":"page"},{"location":"constraint_interface.html","page":"Constraint Interface","title":"Constraint Interface","text":"StageConstraint\nStateConstraint\nControlConstraint\nCoupledConstraint\nCoupledStateConstraint\nCoupledControlConstraint","category":"page"},{"location":"constraint_interface.html#TrajectoryOptimization.StageConstraint","page":"Constraint Interface","title":"TrajectoryOptimization.StageConstraint","text":"Only a function of states and controls at a single knotpoint\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.StateConstraint","page":"Constraint Interface","title":"TrajectoryOptimization.StateConstraint","text":"Only a function of states at a single knotpoint\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.ControlConstraint","page":"Constraint Interface","title":"TrajectoryOptimization.ControlConstraint","text":"Only a function of controls at a single knotpoint\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.CoupledConstraint","page":"Constraint Interface","title":"TrajectoryOptimization.CoupledConstraint","text":"Only a function of states and controls at two adjacent knotpoints\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.CoupledStateConstraint","page":"Constraint Interface","title":"TrajectoryOptimization.CoupledStateConstraint","text":"Only a function of states at adjacent knotpoints\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.CoupledControlConstraint","page":"Constraint Interface","title":"TrajectoryOptimization.CoupledControlConstraint","text":"Only a function of controls at adjacent knotpoints\n\n\n\n\n\n","category":"type"}]
}
