<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimizing Rotations · TrajectoryOptimization</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">TrajectoryOptimization</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="quickstart.html">Quickstart</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="model.html">1. Setting Up a Dynamics Model</a></li><li><a class="tocitem" href="costfunctions.html">2. Setting up an Objective</a></li><li><a class="tocitem" href="constraints.html">3. Creating Constraints</a></li><li><a class="tocitem" href="creating_problems.html">4. Setting up a Problem</a></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="costfunction_interface.html">Cost Function Interface</a></li><li><a class="tocitem" href="constraint_interface.html">Constraint Interface</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="cost_api.html">Cost Functions and Objectives</a></li><li><a class="tocitem" href="constraint_api.html">Constraints</a></li><li><a class="tocitem" href="problem.html">Problem</a></li><li class="is-active"><a class="tocitem" href="rotations.html">Optimizing Rotations</a><ul class="internal"><li><a class="tocitem" href="#Cost-Functions-(experimental)"><span>Cost Functions (experimental)</span></a></li></ul></li></ul></li><li><a class="tocitem" href="examples.html">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href="rotations.html">Optimizing Rotations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="rotations.html">Optimizing Rotations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/master/docs/src/rotations.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Optimizing-Rotations"><a class="docs-heading-anchor" href="#Optimizing-Rotations">Optimizing Rotations</a><a id="Optimizing-Rotations-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizing-Rotations" title="Permalink"></a></h1><p>Optimization over the space of rotations is non-trivial due to the group structure  of 3D rotations. TrajectoryOptimization.jl provides methods for accounting for this group structure, both in the constraints and in the objective. We make the assumption that 3D rotation only show up in the state vector, and never in the control vector. TrajectoryOptimization.jl relies on the dynamics model to determine if the state vector contains rotations. See the  <a href="http://roboticexplorationlab.org/RobotDynamics.jl/dev/liemodel.html">RobotDynamics.jl documentation</a> for more details on defining models with rotations. From here, we assume that we are dealing with a model that inherits from <a href="http://roboticexplorationlab.org/RobotDynamics.jl/dev/liemodel.html#LieGroupModel-API-1"><code>RobotDynamics.LieGroupModel</code></a>.</p><h2 id="Cost-Functions-(experimental)"><a class="docs-heading-anchor" href="#Cost-Functions-(experimental)">Cost Functions (experimental)</a><a id="Cost-Functions-(experimental)-1"></a><a class="docs-heading-anchor-permalink" href="#Cost-Functions-(experimental)" title="Permalink"></a></h2><p>While normal quadratic cost functions can work with rotations (e.g. <span>$q_k^T Q q_k$</span>, where <span>$q_k$</span> is a quaternion, MRP, or RP), this distance metric isn&#39;t well-defined.  Since we often want to penalize the distance from a reference rotation  (such as a nominal or goal state), TrajectoryOptimization.jl provides a couple different methods for penalizing distance from a reference rotation. However, we&#39;ve  discovered that the quaternion geodesic distance: </p><p class="math-container">\[\min 1 \pm q_d^T q_k\]</p><p>where <span>$q_d$</span> is the desired, or reference, quaternion, works the best. We&#39;ve also  found that, while technically incorrect, a naive quadratic penalty can work quite well, especially when the difference between the rotations isn&#39;t significant. </p><p>The following cost functions are provided. Note that these methods should still be  considered experimental, and the interface made change in the future. If you encounter any issues using these functions, please submit an issue.</p><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.DiagonalQuatCost" href="#TrajectoryOptimization.DiagonalQuatCost"><code>TrajectoryOptimization.DiagonalQuatCost</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DiagonalQuatCost</code></pre><p>Quadratic cost function for states that includes a 3D rotation, that penalizes deviations      from a provided 3D rotation, represented as a Unit Quaternion.</p><p>The cost function penalizes geodesic distance between unit quaternions:</p><p><span>$\frac{1}{2} \big( x^T Q x + u^T R u \big) + q^T x + r^T u + c + w \min 1 \pm p_f^T p$</span></p><p>where <span>$p$</span> is the quaternion extracted from <span>$x$</span> (i.e. <code>p = x[q_ind]</code>), and <span>$p_f$</span>  is the reference quaternion. <span>$Q$</span> and <span>$R$</span> are assumed to be diagonal.</p><p>We&#39;ve found this perform better than penalizing a quadratic on the quaternion error  state (<a href="rotations.html#TrajectoryOptimization.ErrorQuadratic"><code>ErrorQuadratic</code></a>). This cost should still be considered experimental.</p><p><strong>Constructors</strong></p><ul><li><code>DiagonalQuatCost(Q::Diagonal, R::Diagonal, q, r, c, w, q_ref, q_ind; terminal)</code></li><li><code>DiagonalQuatCost(Q::Diagonal, R::Diagonal; q, r, c, w, q_ref, q_ind, terminal)</code></li></ul><p>where <code>q_ref</code> is the reference quaternion (provided as a <code>SVector{4}</code>), and      <code>q_ind::SVector{4,Int}</code> provides the indices of the quaternion in the state vector      (default = <code>SA[4,5,6,7]</code>). Note that <code>Q</code> and <code>q</code> are the size of the full state,      so <code>Q.diag[q_ind]</code> and <code>q[qind]</code> should typically be zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/df2b5f4936a7d8ed0b4b79cb5eb93a84084f0fff/src/lie_costs.jl#L9-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.QuatLQRCost" href="#TrajectoryOptimization.QuatLQRCost"><code>TrajectoryOptimization.QuatLQRCost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuatLQRCost(Q, R, xf, [uf; w, quat_ind])</code></pre><p>Defines a cost function of the form:</p><p><span>$\frac{1}{2} \big( (x - x_f)^T Q (x - x_f) + (u - u_f)^T R (u - u_f) \big) + w \min 1 \pm q_f^T q$</span></p><p>where <span>$Q$</span> and <span>$R$</span> are diagonal, <span>$x_f$</span> is the goal state,  <span>$u_f$</span> is the reference control, and <span>$q_f$</span>, <span>$q$</span> are the quaternions, extracted from <span>$x$</span> using <code>quat_ind</code>, i.e. <code>q = x[quat_ind]</code>.</p><p>The last term is the geodesic distance between quaternions. It&#39;s typically recommended that  <code>Q.diag[quad_ind] == zeros(4)</code>.</p><p>This is just a convenience constructor for <a href="rotations.html#TrajectoryOptimization.DiagonalQuatCost"><code>DiagonalQuatCost</code></a>.</p><p><strong>Example</strong></p><p>For a standard rigid body state vector <code>x = [p; q; v; ω]</code>, where <code>q</code> is a unit quaternion, we could define a cost function that penalizes the distance to the goal state <code>xf</code>.  We can create this cost function as follows:</p><pre><code class="language-julia hljs">Q = Diagonal(SVector(RBState(fill(0.1,3), zeros(4), fill(0.1,3), fill(0.1,3))))
R = Diagonal(@SVector fill(0.01, 6))
xf = RBState([1,2,3], rand(UnitQuaternion), zeros(3), zeros(3))
QuatLQRCost(Q,R,xf)</code></pre><p>We can add a reference control and change the weight on the rotation error with the optional arguments:</p><pre><code class="language-julia hljs">QuatLQRCost(Q,R,xf,uf, w=10.0)</code></pre><p>which is equivalent to</p><pre><code class="language-julia hljs">QuatLQRCost(Q,R,xf,uf, w=10.0, quat_inds=4:7)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/df2b5f4936a7d8ed0b4b79cb5eb93a84084f0fff/src/lie_costs.jl#L97-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.ErrorQuadratic" href="#TrajectoryOptimization.ErrorQuadratic"><code>TrajectoryOptimization.ErrorQuadratic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ErrorQuadratic{Rot,N,M}</code></pre><p>Cost function of the form:</p><p><span>$\frac{1}{2} (x_k \ominus x_d)^T Q_k (x_k \ominus x_d)$</span></p><p>where <span>$x_k \ominus x_d$</span> is the error state, computed using  <code>RobotDynamics.state_diff</code>.  This cost function isn&#39;t recommended: we&#39;ve found that <code>DiagonalQuatCost</code> usually     peforms better and is much more computationally efficient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/df2b5f4936a7d8ed0b4b79cb5eb93a84084f0fff/src/lie_costs.jl#L202-L213">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="problem.html">« Problem</a><a class="docs-footer-nextpage" href="examples.html">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Saturday 9 April 2022 21:42">Saturday 9 April 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
