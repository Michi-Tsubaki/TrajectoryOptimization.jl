<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>4. Setting up a Problem · TrajectoryOptimization</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><script src="../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">TrajectoryOptimization</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="model.html">1. Setting Up a Dynamics Model</a></li><li><a class="tocitem" href="costfunctions.html">2. Setting up an Objective</a></li><li><a class="tocitem" href="constraints.html">3. Creating Constraints</a></li><li class="is-active"><a class="tocitem" href="creating_problems.html">4. Setting up a Problem</a><ul class="internal"><li><a class="tocitem" href="#Creating-a-Problem"><span>Creating a Problem</span></a></li><li><a class="tocitem" href="#Initialization"><span>Initialization</span></a></li><li><a class="tocitem" href="#KnotPoint-Type"><span><code>KnotPoint</code> Type</span></a></li><li><a class="tocitem" href="#Traj-Type"><span><code>Traj</code> Type</span></a></li></ul></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="costfunction_interface.html">Cost Function Interface</a></li><li><a class="tocitem" href="constraint_interface.html">Constraint Interface</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="cost_api.html">Cost Functions and Objectives</a></li><li><a class="tocitem" href="constraint_api.html">Constraints</a></li><li><a class="tocitem" href="problem.html">Problem</a></li><li><a class="tocitem" href="rotations.html">Optimizing Rotations</a></li><li><a class="tocitem" href="dynamics.html">Evaluating the Dynamics and Jacobians</a></li><li><a class="tocitem" href="nlp.html">Converting to an NLP</a></li></ul></li><li><a class="tocitem" href="examples.html">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting Started</a></li><li class="is-active"><a href="creating_problems.html">4. Setting up a Problem</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="creating_problems.html">4. Setting up a Problem</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/master/docs/src/creating_problems.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="problem_section"><a class="docs-heading-anchor" href="#problem_section">4. Setting up a Problem</a><a id="problem_section-1"></a><a class="docs-heading-anchor-permalink" href="#problem_section" title="Permalink"></a></h1><p>The <a href="problem.html#TrajectoryOptimization.Problem"><code>Problem</code></a> contains all of the information needed to solve a trajectory optimization problem. At a minimum, this is the model, objective, and initial condition. A <code>Problem</code> is passed to a solver, which extracts needed information, and may or may or not modify its internal representation of the problem in order to solve it (e.g. the Augmented Lagrangian solver combines the constraints and objective into a single Augmented Lagrangian objective.)</p><h2 id="Creating-a-Problem"><a class="docs-heading-anchor" href="#Creating-a-Problem">Creating a Problem</a><a id="Creating-a-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-Problem" title="Permalink"></a></h2><p>Let&#39;s say we&#39;re trying to solve the following trajectory optimization problem:</p><p class="math-container">\[\begin{aligned}
  \min_{x_{0:N},u_{0:N-1}} \quad &amp; (x_N-x_f)^T Q_f (x_N-x_f) + dt \sum_{k=0}^{N-1} (x_k-x_f)^T Q (x_k - x_f) + u^T R u  \\
  \textrm{s.t.}            \quad &amp; x_{k+1} = f(x_k, u_k), \\
                                 &amp; |u_k| \leq 3 \\
                                 &amp; x_N = x_f \\
\end{aligned}\]</p><p>We&#39;ll quickly set up the dynamics, objective, and constraints. See previous sections for more details on how to do this.</p><pre><code class="language-julia hljs">using TrajectoryOptimization
using RobotZoo: Cartpole
using StaticArrays, LinearAlgebra

# Dynamics and Constants
model = Cartpole()
n,m = size(model)
N = 101   # number of knot points
tf = 5.0  # final time
x0 = @SVector [0, 0, 0, 0.]  # initial state
xf = @SVector [0, π, 0, 0.]  # goal state (i.e. swing up)

# Objective
Q = Diagonal(@SVector fill(1e-2,n))
R = Diagonal(@SVector fill(1e-1,m))
Qf = Diagonal(@SVector fill(100.,n))
obj = LQRObjective(Q, R, Qf, xf, N)

# Constraints
conSet = ConstraintList(n,m,N)
bnd = BoundConstraint(n,m, u_min=-3.0, u_max=3.0)
goal = GoalConstraint(xf)
add_constraint!(conSet, bnd, 1:N-1)
add_constraint!(conSet, goal, N:N)</code></pre><p>The following method is the easiest way to set up a trajectory optimization problem:</p><pre><code class="language-julia hljs">prob = Problem(model, obj, xf, tf, constraints=conSet, x0=x0, integration=RK3)</code></pre><p>where the keyword arguments are, of course, optional.</p><p>This constructor has the following arguments:</p><ul><li>(required) <code>model::AbstractModel</code> - dynamics model</li><li>(required) <code>obj::AbstractObjective</code> - objective function</li><li>(required) <code>xf::AbstractVector</code> - goal state (this will be made optional in the near future)</li><li>(required) <code>tf::AbstractFloat</code> - final time</li><li>(optional) <code>constraints::ConstraintSet</code> - constraint set. Default is no constraints.</li><li>(optional) <code>x0::AbstractVector</code> - Initial state. Default is the zero vector.</li><li>(optional) <code>N::Int</code> - number of knot points. Default is given by length of objective.</li><li>(optional) <code>dt::AbstractFloat</code> - Time step length. Can be either a scalar or a vector of length <code>N</code>. Default is calculated using <code>tf</code> and <code>N</code>.</li><li>(optional) <code>integration::Type{&lt;:QuadratureRule}</code> - Quadrature rule for discretizing the dynamics. Default is given by <code>TrajectoryOptimization.DEFAULT_Q</code>.</li><li>(optional) <code>X0</code> - Initial guess for state trajectory. Can either be a matrix of size <code>(n,N)</code> or a vector of length <code>N</code> of <code>n</code>-dimensional vectors.</li><li>(optional) <code>U0</code> - Initial guess for control trajectory. Can either be a matrix of size <code>(m,N)</code> or a vector of length <code>N-1</code> of <code>n</code>-dimensional vectors.</li></ul><h2 id="Initialization"><a class="docs-heading-anchor" href="#Initialization">Initialization</a><a id="Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization" title="Permalink"></a></h2><p>A good initialization is critical to getting good results for nonlinear optimization problems. TrajectoryOptimization.jl current supports initialization of the state and control trajectories. Initialization of dual variables (i.e. Lagrange multipliers) is not yet support but will be included in the near future. The state and control trajectories can be initialized directly in the constructor using the <code>X0</code> and <code>U0</code> keyword arguments described above, or using the following methods:</p><pre><code class="language-julia hljs">initial_states!(prob, X0)
initial_controls!(prob, U0)</code></pre><p>where, again, these can either be matrices or vectors of vectors of the appropriate size. It should be noted that these methods work on either <code>Problem</code>s or instances of <code>AbstractSolver</code>.</p><p>Alternatively, the problem can be initialized with both the state and control trajectories simultaneously by passing in a vector of <code>KnotPoint</code>s, described in the next sections.</p><h2 id="KnotPoint-Type"><a class="docs-heading-anchor" href="#KnotPoint-Type"><code>KnotPoint</code> Type</a><a id="KnotPoint-Type-1"></a><a class="docs-heading-anchor-permalink" href="#KnotPoint-Type" title="Permalink"></a></h2><p>Internally, TrajectoryOptimization.jl stores the state and controls at each time step as a concatenated vector inside the <code>KnotPoint</code> type defined by RobotDynamics.jl. In addition to storing the state and control, the <code>KnotPoint</code> type also stores the time and time step length for the current knot point. See the documention in RobotDynamics for more information.</p><h2 id="Traj-Type"><a class="docs-heading-anchor" href="#Traj-Type"><code>Traj</code> Type</a><a id="Traj-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Traj-Type" title="Permalink"></a></h2><p>The <code>Traj</code> type is simply a vector of <code>KnotPoint</code>s. However, it provides a few helpful methods for constructing and working vectors of <code>KnotPoint</code>s, which effectively describe a discrete-time state-control trajectory.</p><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.Traj" href="#RobotDynamics.Traj"><code>RobotDynamics.Traj</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Traj{n,m,T,KP}</code></pre><p>A vector of <code>AbstractKnotPoint</code>s of type <code>KP</code> with state dimension <code>n</code>, control dimension <code>m</code>, and value type <code>T</code></p><p>Supports iteration and indexing.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">Traj(n, m, dt, N, equal=false)
Traj(x, u, dt, N, equal=false)
Traj(X, U, dt, t)
Traj(X, U, dt)</code></pre></div></section></article><h3 id="Other-Methods"><a class="docs-heading-anchor" href="#Other-Methods">Other Methods</a><a id="Other-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Methods" title="Permalink"></a></h3><p>You can extract the state and control trajectories separately with the following methods:</p><pre><code class="language-julia hljs">states(Z::Traj)
controls(Z::Traj)</code></pre><p>Note that these methods also work on <code>Problem</code>. </p><p>The states, control, and time trajectories can be set independently with the following methods:</p><pre><code class="language-julia hljs">set_states!(Z::Traj, X::Vector{&lt;:AbstractVector})
set_controls!(Z::Traj, U::Vector{&lt;:AbstractVector})
set_times!(Z::Traj, t::Vector)</code></pre><p>To initialize a problem with a given <code>Traj</code> type, you can use</p><pre><code class="nohighlight hljs">initial_trajectory!(::Problem, Z::AbstractTrajectory)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="constraints.html">« 3. Creating Constraints</a><a class="docs-footer-nextpage" href="costfunction_interface.html">Cost Function Interface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Thursday 20 January 2022 22:01">Thursday 20 January 2022</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
